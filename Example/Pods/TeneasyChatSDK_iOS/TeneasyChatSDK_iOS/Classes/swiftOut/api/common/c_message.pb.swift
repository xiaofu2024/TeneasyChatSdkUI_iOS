// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/common/c_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum CommonChatState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 一线任务
  case common // = 0

  /// 转接任务
  case transfer // = 1

  /// 2-4 前端处理(细拆一线任务: 3分钟待回复, 已超时待回复, 已接待)
  /// 未接待-3分钟内
  case unprocessed3Min // = 2

  /// 未接待-3分钟外(已超时)
  case timeout // = 3

  /// 已接待
  case processed // = 4

  /// 黑名单申请(任何非黑名单会话->黑名单待确定)
  case blacklistApply // = 5

  /// 黑名单确定(黑名单待确定->黑名单)
  case blacklistConfirmed // = 6

  /// 未绑定状态
  case free // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .common
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .common
    case 1: self = .transfer
    case 2: self = .unprocessed3Min
    case 3: self = .timeout
    case 4: self = .processed
    case 5: self = .blacklistApply
    case 6: self = .blacklistConfirmed
    case 7: self = .free
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .common: return 0
    case .transfer: return 1
    case .unprocessed3Min: return 2
    case .timeout: return 3
    case .processed: return 4
    case .blacklistApply: return 5
    case .blacklistConfirmed: return 6
    case .free: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonChatState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CommonChatState] = [
    .common,
    .transfer,
    .unprocessed3Min,
    .timeout,
    .processed,
    .blacklistApply,
    .blacklistConfirmed,
    .free,
  ]
}

#endif  // swift(>=4.2)

/// 消息类型
public enum CommonMessageFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 文本
  case msgText // = 0

  /// 图片
  case msgImg // = 1

  /// voice
  case msgVoice // = 2

  /// 视频
  case msgVideo // = 3

  /// 地理位置
  case msgGeo // = 4

  /// 文件
  case msgFile // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .msgText
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgText
    case 1: self = .msgImg
    case 2: self = .msgVoice
    case 3: self = .msgVideo
    case 4: self = .msgGeo
    case 6: self = .msgFile
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .msgText: return 0
    case .msgImg: return 1
    case .msgVoice: return 2
    case .msgVideo: return 3
    case .msgGeo: return 4
    case .msgFile: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CommonMessageFormat] = [
    .msgText,
    .msgImg,
    .msgVoice,
    .msgVideo,
    .msgGeo,
    .msgFile,
  ]
}

#endif  // swift(>=4.2)

/// 消息拥有者角色
public enum CommonMessageRole: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 系统服务
  case msgRoleSystem // = 0

  /// 商户客服工作者
  case msgRoleWorker // = 1

  /// 商户客户
  case msgRoleCustomer // = 2

  /// 商户临时客户 (h5接入)
  case msgRoleAnonymous // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .msgRoleSystem
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgRoleSystem
    case 1: self = .msgRoleWorker
    case 2: self = .msgRoleCustomer
    case 3: self = .msgRoleAnonymous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .msgRoleSystem: return 0
    case .msgRoleWorker: return 1
    case .msgRoleCustomer: return 2
    case .msgRoleAnonymous: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CommonMessageRole] = [
    .msgRoleSystem,
    .msgRoleWorker,
    .msgRoleCustomer,
    .msgRoleAnonymous,
  ]
}

#endif  // swift(>=4.2)

public enum CommonMessageOperate: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// (默认)发送
  case msgOpPost // = 0

  /// 编辑消息
  case msgOpEdit // = 1

  /// 撤回消息
  case msgOpDelete // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .msgOpPost
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgOpPost
    case 1: self = .msgOpEdit
    case 2: self = .msgOpDelete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .msgOpPost: return 0
    case .msgOpEdit: return 1
    case .msgOpDelete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageOperate: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CommonMessageOperate] = [
    .msgOpPost,
    .msgOpEdit,
    .msgOpDelete,
  ]
}

#endif  // swift(>=4.2)

/// 文本消息内容
public struct CommonMessageContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 内容
  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 图片
public struct CommonMessageImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  public var uri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 音频
public struct CommonMessageAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  public var uri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 视频
public struct CommonMessageVideo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  public var uri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 地理位置
public struct CommonMessageGeo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var longitude: String = String()

  public var latitude: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 文件
public struct CommonMessageFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  public var uri: String = String()

  /// 文件名, 去掉目录部分
  public var fileName: String = String()

  /// 文件大小
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommonMessageUnion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: CommonMessageUnion.OneOf_Payload? = nil

  public var content: CommonMessageContent {
    get {
      if case .content(let v)? = payload {return v}
      return CommonMessageContent()
    }
    set {payload = .content(newValue)}
  }

  public var image: CommonMessageImage {
    get {
      if case .image(let v)? = payload {return v}
      return CommonMessageImage()
    }
    set {payload = .image(newValue)}
  }

  public var audio: CommonMessageAudio {
    get {
      if case .audio(let v)? = payload {return v}
      return CommonMessageAudio()
    }
    set {payload = .audio(newValue)}
  }

  public var video: CommonMessageVideo {
    get {
      if case .video(let v)? = payload {return v}
      return CommonMessageVideo()
    }
    set {payload = .video(newValue)}
  }

  public var geo: CommonMessageGeo {
    get {
      if case .geo(let v)? = payload {return v}
      return CommonMessageGeo()
    }
    set {payload = .geo(newValue)}
  }

  public var file: CommonMessageFile {
    get {
      if case .file(let v)? = payload {return v}
      return CommonMessageFile()
    }
    set {payload = .file(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case content(CommonMessageContent)
    case image(CommonMessageImage)
    case audio(CommonMessageAudio)
    case video(CommonMessageVideo)
    case geo(CommonMessageGeo)
    case file(CommonMessageFile)

  #if !swift(>=4.1)
    public static func ==(lhs: CommonMessageUnion.OneOf_Payload, rhs: CommonMessageUnion.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geo, .geo): return {
        guard case .geo(let l) = lhs, case .geo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct CommonMessageAutoReplyQA {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 序号
  public var id: Int32 = 0

  /// 常见问题
  public var question: CommonMessageUnion {
    get {return _question ?? CommonMessageUnion()}
    set {_question = newValue}
  }
  /// Returns true if `question` has been explicitly set.
  public var hasQuestion: Bool {return self._question != nil}
  /// Clears the value of `question`. Subsequent reads from it will return its default value.
  public mutating func clearQuestion() {self._question = nil}

  /// 回答
  public var answer: [CommonMessageUnion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _question: CommonMessageUnion? = nil
}

/// 自动回复消息
public struct CommonMessageAutoReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// 引导文案
  public var title: String = String()

  /// 延迟回复时间
  public var delaySec: Int32 = 0

  /// 问答
  public var qa: [CommonMessageAutoReplyQA] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommonMessageKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var msgID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommonMessageAutoReplyFlag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AutoReplyItem.id
  public var id: Int64 = 0

  /// 指定的问题序号id: QuestionAnswer.id
  public var qaID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommonMessageWorkerChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerClientID: Int64 = 0

  public var workerID: Int32 = 0

  public var name: String = String()

  public var avatar: String = String()

  public var greeting: String = String()

  ///转接任务
  public var state: CommonChatState = .common

  /// 咨询类型
  public var consultID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommonMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 会话id(指此次聊天会话的id, 实际上是 终端用户 的 client id)
  /// 此处避免与连接session混淆, 用chat id区分
  /// 对于终端用户(h5, web), 无视此字段(服务端填入)
  /// 对于客服(pc), 发消息时填对应会话的id
  /// 对于持久化, 可作为 分区 id
  public var chatID: Int64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  /// 消息id, 服务端分配
  public var msgID: Int64 {
    get {return _storage._msgID}
    set {_uniqueStorage()._msgID = newValue}
  }

  /// 消息发送时间, 服务端分配
  public var msgTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._msgTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._msgTime = newValue}
  }
  /// Returns true if `msgTime` has been explicitly set.
  public var hasMsgTime: Bool {return _storage._msgTime != nil}
  /// Clears the value of `msgTime`. Subsequent reads from it will return its default value.
  public mutating func clearMsgTime() {_uniqueStorage()._msgTime = nil}

  /// 发送人, 服务端记录
  /// 发送人为0 = 系统消息
  public var sender: Int64 {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  /// 回复消息
  public var replyMsgID: Int64 {
    get {return _storage._replyMsgID}
    set {_uniqueStorage()._replyMsgID = newValue}
  }

  /// 消息操作人
  public var msgOp: CommonMessageOperate {
    get {return _storage._msgOp}
    set {_uniqueStorage()._msgOp = newValue}
  }

  /// 分配客服id
  public var worker: Int32 {
    get {return _storage._worker}
    set {_uniqueStorage()._worker = newValue}
  }

  /// 自动回复选项, 历史原因保留(没规划好, 应该放到payload中)
  public var autoReplyFlag: CommonMessageAutoReplyFlag {
    get {return _storage._autoReplyFlag ?? CommonMessageAutoReplyFlag()}
    set {_uniqueStorage()._autoReplyFlag = newValue}
  }
  /// Returns true if `autoReplyFlag` has been explicitly set.
  public var hasAutoReplyFlag: Bool {return _storage._autoReplyFlag != nil}
  /// Clears the value of `autoReplyFlag`. Subsequent reads from it will return its default value.
  public mutating func clearAutoReplyFlag() {_uniqueStorage()._autoReplyFlag = nil}

  /// 消息类型
  public var msgFmt: CommonMessageFormat {
    get {return _storage._msgFmt}
    set {_uniqueStorage()._msgFmt = newValue}
  }

  /// 咨询类型
  public var consultID: Int64 {
    get {return _storage._consultID}
    set {_uniqueStorage()._consultID = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var content: CommonMessageContent {
    get {
      if case .content(let v)? = _storage._payload {return v}
      return CommonMessageContent()
    }
    set {_uniqueStorage()._payload = .content(newValue)}
  }

  public var image: CommonMessageImage {
    get {
      if case .image(let v)? = _storage._payload {return v}
      return CommonMessageImage()
    }
    set {_uniqueStorage()._payload = .image(newValue)}
  }

  public var audio: CommonMessageAudio {
    get {
      if case .audio(let v)? = _storage._payload {return v}
      return CommonMessageAudio()
    }
    set {_uniqueStorage()._payload = .audio(newValue)}
  }

  public var video: CommonMessageVideo {
    get {
      if case .video(let v)? = _storage._payload {return v}
      return CommonMessageVideo()
    }
    set {_uniqueStorage()._payload = .video(newValue)}
  }

  public var geo: CommonMessageGeo {
    get {
      if case .geo(let v)? = _storage._payload {return v}
      return CommonMessageGeo()
    }
    set {_uniqueStorage()._payload = .geo(newValue)}
  }

  public var file: CommonMessageFile {
    get {
      if case .file(let v)? = _storage._payload {return v}
      return CommonMessageFile()
    }
    set {_uniqueStorage()._payload = .file(newValue)}
  }

  /// 已转接至客服 xxx
  public var workerTrans: CommonWorkerTransfer {
    get {
      if case .workerTrans(let v)? = _storage._payload {return v}
      return CommonWorkerTransfer()
    }
    set {_uniqueStorage()._payload = .workerTrans(newValue)}
  }

  /// 请求将此会话拉入黑名单
  public var blacklistApply: CommonBlackListApply {
    get {
      if case .blacklistApply(let v)? = _storage._payload {return v}
      return CommonBlackListApply()
    }
    set {_uniqueStorage()._payload = .blacklistApply(newValue)}
  }

  /// 确认拉入黑名单
  public var blacklistConfirm: CommonBlackListConfirm {
    get {
      if case .blacklistConfirm(let v)? = _storage._payload {return v}
      return CommonBlackListConfirm()
    }
    set {_uniqueStorage()._payload = .blacklistConfirm(newValue)}
  }

  /// 自动回复问题
  public var autoReply: CommonMessageAutoReply {
    get {
      if case .autoReply(let v)? = _storage._payload {return v}
      return CommonMessageAutoReply()
    }
    set {_uniqueStorage()._payload = .autoReply(newValue)}
  }

  /// 客服改变
  public var workerChanged: CommonMessageWorkerChanged {
    get {
      if case .workerChanged(let v)? = _storage._payload {return v}
      return CommonMessageWorkerChanged()
    }
    set {_uniqueStorage()._payload = .workerChanged(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case content(CommonMessageContent)
    case image(CommonMessageImage)
    case audio(CommonMessageAudio)
    case video(CommonMessageVideo)
    case geo(CommonMessageGeo)
    case file(CommonMessageFile)
    /// 已转接至客服 xxx
    case workerTrans(CommonWorkerTransfer)
    /// 请求将此会话拉入黑名单
    case blacklistApply(CommonBlackListApply)
    /// 确认拉入黑名单
    case blacklistConfirm(CommonBlackListConfirm)
    /// 自动回复问题
    case autoReply(CommonMessageAutoReply)
    /// 客服改变
    case workerChanged(CommonMessageWorkerChanged)

  #if !swift(>=4.1)
    public static func ==(lhs: CommonMessage.OneOf_Payload, rhs: CommonMessage.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geo, .geo): return {
        guard case .geo(let l) = lhs, case .geo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workerTrans, .workerTrans): return {
        guard case .workerTrans(let l) = lhs, case .workerTrans(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blacklistApply, .blacklistApply): return {
        guard case .blacklistApply(let l) = lhs, case .blacklistApply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blacklistConfirm, .blacklistConfirm): return {
        guard case .blacklistConfirm(let l) = lhs, case .blacklistConfirm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoReply, .autoReply): return {
        guard case .autoReply(let l) = lhs, case .autoReply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workerChanged, .workerChanged): return {
        guard case .workerChanged(let l) = lhs, case .workerChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct CommonWorkerTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var workerName: String = String()

  public var workerAvatar: String = String()

  /// 咨询类型
  public var consultID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求拉入黑名单
public struct CommonBlackListApply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 目标客服
  /// 目标客服 需有 操作黑名单权限
  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 确认拉入黑名单
public struct CommonBlackListConfirm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作客服
  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CommonChatState: @unchecked Sendable {}
extension CommonMessageFormat: @unchecked Sendable {}
extension CommonMessageRole: @unchecked Sendable {}
extension CommonMessageOperate: @unchecked Sendable {}
extension CommonMessageContent: @unchecked Sendable {}
extension CommonMessageImage: @unchecked Sendable {}
extension CommonMessageAudio: @unchecked Sendable {}
extension CommonMessageVideo: @unchecked Sendable {}
extension CommonMessageGeo: @unchecked Sendable {}
extension CommonMessageFile: @unchecked Sendable {}
extension CommonMessageUnion: @unchecked Sendable {}
extension CommonMessageUnion.OneOf_Payload: @unchecked Sendable {}
extension CommonMessageAutoReplyQA: @unchecked Sendable {}
extension CommonMessageAutoReply: @unchecked Sendable {}
extension CommonMessageKey: @unchecked Sendable {}
extension CommonMessageAutoReplyFlag: @unchecked Sendable {}
extension CommonMessageWorkerChanged: @unchecked Sendable {}
extension CommonMessage: @unchecked Sendable {}
extension CommonMessage.OneOf_Payload: @unchecked Sendable {}
extension CommonWorkerTransfer: @unchecked Sendable {}
extension CommonBlackListApply: @unchecked Sendable {}
extension CommonBlackListConfirm: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.common"

extension CommonChatState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT_STATE_COMMON"),
    1: .same(proto: "CHAT_STATE_TRANSFER"),
    2: .same(proto: "CHAT_STATE_UNPROCESSED_3MIN"),
    3: .same(proto: "CHAT_STATE_TIMEOUT"),
    4: .same(proto: "CHAT_STATE_PROCESSED"),
    5: .same(proto: "CHAT_STATE_BLACKLIST_APPLY"),
    6: .same(proto: "CHAT_STATE_BLACKLIST_CONFIRMED"),
    7: .same(proto: "CHAT_STATE_FREE"),
  ]
}

extension CommonMessageFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_TEXT"),
    1: .same(proto: "MSG_IMG"),
    2: .same(proto: "MSG_VOICE"),
    3: .same(proto: "MSG_VIDEO"),
    4: .same(proto: "MSG_GEO"),
    6: .same(proto: "MSG_FILE"),
  ]
}

extension CommonMessageRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_ROLE_SYSTEM"),
    1: .same(proto: "MSG_ROLE_WORKER"),
    2: .same(proto: "MSG_ROLE_CUSTOMER"),
    3: .same(proto: "MSG_ROLE_ANONYMOUS"),
  ]
}

extension CommonMessageOperate: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_OP_POST"),
    1: .same(proto: "MSG_OP_EDIT"),
    2: .same(proto: "MSG_OP_DELETE"),
  ]
}

extension CommonMessageContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageContent, rhs: CommonMessageContent) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageImage, rhs: CommonMessageImage) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageAudio, rhs: CommonMessageAudio) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageVideo, rhs: CommonMessageVideo) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageGeo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageGeo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.longitude.isEmpty {
      try visitor.visitSingularStringField(value: self.longitude, fieldNumber: 1)
    }
    if !self.latitude.isEmpty {
      try visitor.visitSingularStringField(value: self.latitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageGeo, rhs: CommonMessageGeo) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "file_name"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageFile, rhs: CommonMessageFile) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageUnion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageUnion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "image"),
    3: .same(proto: "audio"),
    4: .same(proto: "video"),
    5: .same(proto: "geo"),
    6: .same(proto: "file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CommonMessageContent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .content(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .content(v)
        }
      }()
      case 2: try {
        var v: CommonMessageImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .image(v)
        }
      }()
      case 3: try {
        var v: CommonMessageAudio?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .audio(v)
        }
      }()
      case 4: try {
        var v: CommonMessageVideo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .video(v)
        }
      }()
      case 5: try {
        var v: CommonMessageGeo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .geo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .geo(v)
        }
      }()
      case 6: try {
        var v: CommonMessageFile?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .file(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .file(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .content?: try {
      guard case .content(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .image?: try {
      guard case .image(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .video?: try {
      guard case .video(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .geo?: try {
      guard case .geo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .file?: try {
      guard case .file(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageUnion, rhs: CommonMessageUnion) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageAutoReplyQA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageAutoReplyQA"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "question"),
    3: .same(proto: "answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._question) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.answer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._question {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.answer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageAutoReplyQA, rhs: CommonMessageAutoReplyQA) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._question != rhs._question {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageAutoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageAutoReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .standard(proto: "delay_sec"),
    4: .same(proto: "qa"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.delaySec) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.qa) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.delaySec != 0 {
      try visitor.visitSingularInt32Field(value: self.delaySec, fieldNumber: 3)
    }
    if !self.qa.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qa, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageAutoReply, rhs: CommonMessageAutoReply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.delaySec != rhs.delaySec {return false}
    if lhs.qa != rhs.qa {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "msg_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.msgID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.msgID != 0 {
      try visitor.visitSingularInt64Field(value: self.msgID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageKey, rhs: CommonMessageKey) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageAutoReplyFlag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageAutoReplyFlag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "qa_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.qaID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.qaID != 0 {
      try visitor.visitSingularInt32Field(value: self.qaID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageAutoReplyFlag, rhs: CommonMessageAutoReplyFlag) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.qaID != rhs.qaID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageWorkerChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageWorkerChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_client_id"),
    2: .standard(proto: "worker_id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
    5: .same(proto: "greeting"),
    6: .same(proto: "State"),
    7: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workerClientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.greeting) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerClientID != 0 {
      try visitor.visitSingularInt64Field(value: self.workerClientID, fieldNumber: 1)
    }
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    if !self.greeting.isEmpty {
      try visitor.visitSingularStringField(value: self.greeting, fieldNumber: 5)
    }
    if self.state != .common {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if self.consultID != 0 {
      try visitor.visitSingularInt64Field(value: self.consultID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessageWorkerChanged, rhs: CommonMessageWorkerChanged) -> Bool {
    if lhs.workerClientID != rhs.workerClientID {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.greeting != rhs.greeting {return false}
    if lhs.state != rhs.state {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "msg_id"),
    3: .standard(proto: "msg_time"),
    4: .same(proto: "sender"),
    5: .standard(proto: "reply_msg_id"),
    6: .standard(proto: "msg_op"),
    7: .same(proto: "worker"),
    8: .standard(proto: "auto_reply_flag"),
    9: .standard(proto: "msg_fmt"),
    10: .standard(proto: "consult_id"),
    100: .same(proto: "content"),
    101: .same(proto: "image"),
    102: .same(proto: "audio"),
    103: .same(proto: "video"),
    104: .same(proto: "geo"),
    105: .same(proto: "file"),
    106: .standard(proto: "worker_trans"),
    107: .standard(proto: "blacklist_apply"),
    108: .standard(proto: "blacklist_confirm"),
    109: .standard(proto: "auto_reply"),
    110: .standard(proto: "worker_changed"),
  ]

  fileprivate class _StorageClass {
    var _chatID: Int64 = 0
    var _msgID: Int64 = 0
    var _msgTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _sender: Int64 = 0
    var _replyMsgID: Int64 = 0
    var _msgOp: CommonMessageOperate = .msgOpPost
    var _worker: Int32 = 0
    var _autoReplyFlag: CommonMessageAutoReplyFlag? = nil
    var _msgFmt: CommonMessageFormat = .msgText
    var _consultID: Int64 = 0
    var _payload: CommonMessage.OneOf_Payload?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _msgID = source._msgID
      _msgTime = source._msgTime
      _sender = source._sender
      _replyMsgID = source._replyMsgID
      _msgOp = source._msgOp
      _worker = source._worker
      _autoReplyFlag = source._autoReplyFlag
      _msgFmt = source._msgFmt
      _consultID = source._consultID
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._msgID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._msgTime) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._sender) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._replyMsgID) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._msgOp) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._worker) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._autoReplyFlag) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._msgFmt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._consultID) }()
        case 100: try {
          var v: CommonMessageContent?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .content(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .content(v)
          }
        }()
        case 101: try {
          var v: CommonMessageImage?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .image(v)
          }
        }()
        case 102: try {
          var v: CommonMessageAudio?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .audio(v)
          }
        }()
        case 103: try {
          var v: CommonMessageVideo?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .video(v)
          }
        }()
        case 104: try {
          var v: CommonMessageGeo?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .geo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .geo(v)
          }
        }()
        case 105: try {
          var v: CommonMessageFile?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .file(v)
          }
        }()
        case 106: try {
          var v: CommonWorkerTransfer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workerTrans(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workerTrans(v)
          }
        }()
        case 107: try {
          var v: CommonBlackListApply?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .blacklistApply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .blacklistApply(v)
          }
        }()
        case 108: try {
          var v: CommonBlackListConfirm?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .blacklistConfirm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .blacklistConfirm(v)
          }
        }()
        case 109: try {
          var v: CommonMessageAutoReply?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .autoReply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .autoReply(v)
          }
        }()
        case 110: try {
          var v: CommonMessageWorkerChanged?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workerChanged(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workerChanged(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._chatID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chatID, fieldNumber: 1)
      }
      if _storage._msgID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgID, fieldNumber: 2)
      }
      try { if let v = _storage._msgTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._sender != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sender, fieldNumber: 4)
      }
      if _storage._replyMsgID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._replyMsgID, fieldNumber: 5)
      }
      if _storage._msgOp != .msgOpPost {
        try visitor.visitSingularEnumField(value: _storage._msgOp, fieldNumber: 6)
      }
      if _storage._worker != 0 {
        try visitor.visitSingularInt32Field(value: _storage._worker, fieldNumber: 7)
      }
      try { if let v = _storage._autoReplyFlag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._msgFmt != .msgText {
        try visitor.visitSingularEnumField(value: _storage._msgFmt, fieldNumber: 9)
      }
      if _storage._consultID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._consultID, fieldNumber: 10)
      }
      switch _storage._payload {
      case .content?: try {
        guard case .content(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }()
      case .image?: try {
        guard case .image(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }()
      case .audio?: try {
        guard case .audio(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }()
      case .geo?: try {
        guard case .geo(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }()
      case .file?: try {
        guard case .file(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }()
      case .workerTrans?: try {
        guard case .workerTrans(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      }()
      case .blacklistApply?: try {
        guard case .blacklistApply(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
      }()
      case .blacklistConfirm?: try {
        guard case .blacklistConfirm(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      }()
      case .autoReply?: try {
        guard case .autoReply(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
      }()
      case .workerChanged?: try {
        guard case .workerChanged(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonMessage, rhs: CommonMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._msgID != rhs_storage._msgID {return false}
        if _storage._msgTime != rhs_storage._msgTime {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._replyMsgID != rhs_storage._replyMsgID {return false}
        if _storage._msgOp != rhs_storage._msgOp {return false}
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._autoReplyFlag != rhs_storage._autoReplyFlag {return false}
        if _storage._msgFmt != rhs_storage._msgFmt {return false}
        if _storage._consultID != rhs_storage._consultID {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonWorkerTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "worker_name"),
    3: .standard(proto: "worker_avatar"),
    4: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workerName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workerAvatar) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.workerName.isEmpty {
      try visitor.visitSingularStringField(value: self.workerName, fieldNumber: 2)
    }
    if !self.workerAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.workerAvatar, fieldNumber: 3)
    }
    if self.consultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.consultID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonWorkerTransfer, rhs: CommonWorkerTransfer) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.workerName != rhs.workerName {return false}
    if lhs.workerAvatar != rhs.workerAvatar {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonBlackListApply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlackListApply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonBlackListApply, rhs: CommonBlackListApply) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonBlackListConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlackListConfirm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommonBlackListConfirm, rhs: CommonBlackListConfirm) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
