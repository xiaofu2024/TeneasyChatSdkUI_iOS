// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/tenant.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///线路选择
///0客服，1用户，2混合
public enum Api_Core_RoleRoute: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case worker // = 0
  case customer // = 1
  case all // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .worker
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .worker
    case 1: self = .customer
    case 2: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .worker: return 0
    case .customer: return 1
    case .all: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_RoleRoute: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_RoleRoute] = [
    .worker,
    .customer,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// 分页参数
public struct Api_Core_PageParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量
  public var size: UInt32 = 0

  /// 当前页
  public var page: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 角色id
  public var roleID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routeName: String = String()

  public var routeURL: String = String()

  public var routeRole: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routes: [Api_Core_RouteItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户名最多16个中文字符（字母、数字、特殊符号中包含两种）（必填）
  public var account: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_LoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// 客服信息
  public var items: Api_Common_Worker {
    get {return _storage._items ?? Api_Common_Worker()}
    set {_uniqueStorage()._items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return _storage._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {_uniqueStorage()._items = nil}

  /// 过期时间（分）
  public var chatExpireTime: Int32 {
    get {return _storage._chatExpireTime}
    set {_uniqueStorage()._chatExpireTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 登录下级账号
public struct Api_Core_ManagerLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_ManagerLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// 客服信息, 此处字段名和 LoginResponse 保持一致
  public var items: Api_Common_Worker {
    get {return _storage._items ?? Api_Common_Worker()}
    set {_uniqueStorage()._items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return _storage._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {_uniqueStorage()._items = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Api_Core_TenantCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户名 商户名称最少1位，最多16个字符
  public var name: String = String()

  /// 商户账号 用户名最少3位，最多16个字符
  public var account: String = String()

  /// 密码最少6位最多20个字符，至少包括字母、数字、特殊符号其中两种。
  public var password: String = String()

  /// 客服数量最高9999
  public var workerCapacity: Int32 = 0

  /// 每日接待人数
  public var dailyServiceCapacity: Int32 = 0

  /// 商户分组
  public var cliqueID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_TenantQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var tenantItem: [Api_Core_TenantItem] = []

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_DeleteTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tenantID: UInt32 = 0

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 {
    get {return _storage._tenantID}
    set {_uniqueStorage()._tenantID = newValue}
  }

  /// 商户绑定公钥
  public var tenantPublicKey: String {
    get {return _storage._tenantPublicKey}
    set {_uniqueStorage()._tenantPublicKey = newValue}
  }

  /// 商户名称
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// 最大工作人员数量
  public var workersCapacity: Int32 {
    get {return _storage._workersCapacity}
    set {_uniqueStorage()._workersCapacity = newValue}
  }

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 {
    get {return _storage._dailyServiceCapacity}
    set {_uniqueStorage()._dailyServiceCapacity = newValue}
  }

  /// 入口数量
  public var entranceNum: Int32 {
    get {return _storage._entranceNum}
    set {_uniqueStorage()._entranceNum = newValue}
  }

  /// 用户名(商户账号)
  public var userName: String {
    get {return _storage._userName}
    set {_uniqueStorage()._userName = newValue}
  }

  /// 月均咨询量
  public var averageMonthly: Int32 {
    get {return _storage._averageMonthly}
    set {_uniqueStorage()._averageMonthly = newValue}
  }

  /// 累计咨询量
  public var cumulativeVolume: Int32 {
    get {return _storage._cumulativeVolume}
    set {_uniqueStorage()._cumulativeVolume = newValue}
  }

  /// 商户账号密码
  public var password: String {
    get {return _storage._password}
    set {_uniqueStorage()._password = newValue}
  }

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return _storage._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {_uniqueStorage()._createAt = nil}

  /// 删除时间（依次判断是否已删除）
  public var deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deleteAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deleteAt = newValue}
  }
  /// Returns true if `deleteAt` has been explicitly set.
  public var hasDeleteAt: Bool {return _storage._deleteAt != nil}
  /// Clears the value of `deleteAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteAt() {_uniqueStorage()._deleteAt = nil}

  /// 所在分组名称
  public var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  /// 所在分组名称
  public var cliqueID: Int32 {
    get {return _storage._cliqueID}
    set {_uniqueStorage()._cliqueID = newValue}
  }

  public var apiRequestURL: String {
    get {return _storage._apiRequestURL}
    set {_uniqueStorage()._apiRequestURL = newValue}
  }

  public var apiName: String {
    get {return _storage._apiName}
    set {_uniqueStorage()._apiName = newValue}
  }

  public var apiPwd: String {
    get {return _storage._apiPwd}
    set {_uniqueStorage()._apiPwd = newValue}
  }

  public var apiPubKey: String {
    get {return _storage._apiPubKey}
    set {_uniqueStorage()._apiPubKey = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Api_Core_AdminLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_AdminLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: 修改商户登录账号和密码
public struct Api_Core_UpdateTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  /// 商户名称
  public var name: String = String()

  /// 客服数量
  public var workerCapacity: Int32 = 0

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 = 0

  /// 商户账号密码(密码调整)
  public var password: String = String()

  /// 商户分组
  public var cliqueID: Int32 = 0

  /// 商户云信前缀
  public var nimprex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_PublicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///key
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryTenantInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Api_Core_TenantItem {
    get {return _item ?? Api_Core_TenantItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Api_Core_TenantItem? = nil
}

/// TODO: 更新云信信息
public struct Api_Core_UpdateNimInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var nimid: String = String()

  public var nimsession: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: 更新云信信息
public struct Api_Core_VersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 {
    get {return _versionID ?? 0}
    set {_versionID = newValue}
  }
  /// Returns true if `versionID` has been explicitly set.
  public var hasVersionID: Bool {return self._versionID != nil}
  /// Clears the value of `versionID`. Subsequent reads from it will return its default value.
  public mutating func clearVersionID() {self._versionID = nil}

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  public var status: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _versionID: Int32? = nil
}

public struct Api_Core_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return self._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {self._createAt = nil}

  /// 更新时间
  public var updateAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateAt = newValue}
  }
  /// Returns true if `updateAt` has been explicitly set.
  public var hasUpdateAt: Bool {return self._updateAt != nil}
  /// Clears the value of `updateAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateAt() {self._updateAt = nil}

  public var status: Int32 = 0

  public var `operator`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_CreateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_UpdateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return self._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {self._createAt = nil}

  /// 更新时间
  public var updateAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateAt = newValue}
  }
  /// Returns true if `updateAt` has been explicitly set.
  public var hasUpdateAt: Bool {return self._updateAt != nil}
  /// Clears the value of `updateAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateAt() {self._updateAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_GetVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分配一线客服
  public var list: [Api_Core_VersionResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantThirdSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  public var apiRequestURL: String = String()

  public var apiName: String = String()

  public var apiPwd: String = String()

  public var apiPubKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_RoleRoute: @unchecked Sendable {}
extension Api_Core_PageParam: @unchecked Sendable {}
extension Api_Core_RouteRequest: @unchecked Sendable {}
extension Api_Core_RouteItem: @unchecked Sendable {}
extension Api_Core_RouteResponse: @unchecked Sendable {}
extension Api_Core_LoginRequest: @unchecked Sendable {}
extension Api_Core_LoginResponse: @unchecked Sendable {}
extension Api_Core_ManagerLoginRequest: @unchecked Sendable {}
extension Api_Core_ManagerLoginResponse: @unchecked Sendable {}
extension Api_Core_TenantCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryResponse: @unchecked Sendable {}
extension Api_Core_DeleteTenantRequest: @unchecked Sendable {}
extension Api_Core_TenantItem: @unchecked Sendable {}
extension Api_Core_AdminLoginRequest: @unchecked Sendable {}
extension Api_Core_AdminLoginResponse: @unchecked Sendable {}
extension Api_Core_UpdateTenantRequest: @unchecked Sendable {}
extension Api_Core_PublicKeyResponse: @unchecked Sendable {}
extension Api_Core_QueryTenantInfoResponse: @unchecked Sendable {}
extension Api_Core_UpdateNimInfoRequest: @unchecked Sendable {}
extension Api_Core_VersionRequest: @unchecked Sendable {}
extension Api_Core_VersionResponse: @unchecked Sendable {}
extension Api_Core_CreateVersionResponse: @unchecked Sendable {}
extension Api_Core_UpdateVersionResponse: @unchecked Sendable {}
extension Api_Core_GetVersionResponse: @unchecked Sendable {}
extension Api_Core_TenantThirdSetting: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_RoleRoute: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Role_ROUTE_WORKER"),
    1: .same(proto: "Role_ROUTE_CUSTOMER"),
    2: .same(proto: "Role_ROUTE_ALL"),
  ]
}

extension Api_Core_PageParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt64Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PageParam, rhs: Api_Core_PageParam) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteRequest, rhs: Api_Core_RouteRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_name"),
    2: .standard(proto: "route_url"),
    3: .standard(proto: "route_role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.routeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routeURL) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.routeRole) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routeName.isEmpty {
      try visitor.visitSingularStringField(value: self.routeName, fieldNumber: 1)
    }
    if !self.routeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.routeURL, fieldNumber: 2)
    }
    if self.routeRole != 0 {
      try visitor.visitSingularInt32Field(value: self.routeRole, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteItem, rhs: Api_Core_RouteItem) -> Bool {
    if lhs.routeName != rhs.routeName {return false}
    if lhs.routeURL != rhs.routeURL {return false}
    if lhs.routeRole != rhs.routeRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteResponse, rhs: Api_Core_RouteResponse) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginRequest, rhs: Api_Core_LoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
    3: .standard(proto: "chat_expire_time"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _items: Api_Common_Worker? = nil
    var _chatExpireTime: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _items = source._items
      _chatExpireTime = source._chatExpireTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._items) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._chatExpireTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      try { if let v = _storage._items {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._chatExpireTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._chatExpireTime, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginResponse, rhs: Api_Core_LoginResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._chatExpireTime != rhs_storage._chatExpireTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginRequest, rhs: Api_Core_ManagerLoginRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _items: Api_Common_Worker? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._items) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      try { if let v = _storage._items {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginResponse, rhs: Api_Core_ManagerLoginResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "account"),
    3: .same(proto: "password"),
    4: .standard(proto: "worker_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "clique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 4)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantCreateRequest, rhs: Api_Core_TenantCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryRequest, rhs: Api_Core_TenantQueryRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
    4: .standard(proto: "tenant_item"),
    5: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tenantItem) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    if !self.tenantItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tenantItem, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryResponse, rhs: Api_Core_TenantQueryResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.tenantItem != rhs.tenantItem {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DeleteTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DeleteTenantRequest, rhs: Api_Core_DeleteTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "tenant_public_key"),
    3: .same(proto: "name"),
    4: .standard(proto: "workers_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "entrance_num"),
    7: .standard(proto: "user_name"),
    8: .standard(proto: "average_monthly"),
    9: .standard(proto: "cumulative_volume"),
    10: .same(proto: "password"),
    11: .standard(proto: "create_at"),
    12: .standard(proto: "delete_at"),
    13: .standard(proto: "group_name"),
    14: .standard(proto: "clique_Id"),
    15: .standard(proto: "api_request_url"),
    16: .standard(proto: "api_name"),
    17: .standard(proto: "api_pwd"),
    18: .standard(proto: "api_pubKey"),
  ]

  fileprivate class _StorageClass {
    var _tenantID: UInt32 = 0
    var _tenantPublicKey: String = String()
    var _name: String = String()
    var _workersCapacity: Int32 = 0
    var _dailyServiceCapacity: Int32 = 0
    var _entranceNum: Int32 = 0
    var _userName: String = String()
    var _averageMonthly: Int32 = 0
    var _cumulativeVolume: Int32 = 0
    var _password: String = String()
    var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _groupName: String = String()
    var _cliqueID: Int32 = 0
    var _apiRequestURL: String = String()
    var _apiName: String = String()
    var _apiPwd: String = String()
    var _apiPubKey: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tenantID = source._tenantID
      _tenantPublicKey = source._tenantPublicKey
      _name = source._name
      _workersCapacity = source._workersCapacity
      _dailyServiceCapacity = source._dailyServiceCapacity
      _entranceNum = source._entranceNum
      _userName = source._userName
      _averageMonthly = source._averageMonthly
      _cumulativeVolume = source._cumulativeVolume
      _password = source._password
      _createAt = source._createAt
      _deleteAt = source._deleteAt
      _groupName = source._groupName
      _cliqueID = source._cliqueID
      _apiRequestURL = source._apiRequestURL
      _apiName = source._apiName
      _apiPwd = source._apiPwd
      _apiPubKey = source._apiPubKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._tenantID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._tenantPublicKey) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._workersCapacity) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._dailyServiceCapacity) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._entranceNum) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._userName) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._averageMonthly) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._cumulativeVolume) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createAt) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._deleteAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._cliqueID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._apiRequestURL) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._apiName) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._apiPwd) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._apiPubKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._tenantID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tenantID, fieldNumber: 1)
      }
      if !_storage._tenantPublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tenantPublicKey, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if _storage._workersCapacity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._workersCapacity, fieldNumber: 4)
      }
      if _storage._dailyServiceCapacity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dailyServiceCapacity, fieldNumber: 5)
      }
      if _storage._entranceNum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._entranceNum, fieldNumber: 6)
      }
      if !_storage._userName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userName, fieldNumber: 7)
      }
      if _storage._averageMonthly != 0 {
        try visitor.visitSingularInt32Field(value: _storage._averageMonthly, fieldNumber: 8)
      }
      if _storage._cumulativeVolume != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cumulativeVolume, fieldNumber: 9)
      }
      if !_storage._password.isEmpty {
        try visitor.visitSingularStringField(value: _storage._password, fieldNumber: 10)
      }
      try { if let v = _storage._createAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._deleteAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 13)
      }
      if _storage._cliqueID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cliqueID, fieldNumber: 14)
      }
      if !_storage._apiRequestURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiRequestURL, fieldNumber: 15)
      }
      if !_storage._apiName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiName, fieldNumber: 16)
      }
      if !_storage._apiPwd.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiPwd, fieldNumber: 17)
      }
      if !_storage._apiPubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiPubKey, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantItem, rhs: Api_Core_TenantItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tenantID != rhs_storage._tenantID {return false}
        if _storage._tenantPublicKey != rhs_storage._tenantPublicKey {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._workersCapacity != rhs_storage._workersCapacity {return false}
        if _storage._dailyServiceCapacity != rhs_storage._dailyServiceCapacity {return false}
        if _storage._entranceNum != rhs_storage._entranceNum {return false}
        if _storage._userName != rhs_storage._userName {return false}
        if _storage._averageMonthly != rhs_storage._averageMonthly {return false}
        if _storage._cumulativeVolume != rhs_storage._cumulativeVolume {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._createAt != rhs_storage._createAt {return false}
        if _storage._deleteAt != rhs_storage._deleteAt {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._cliqueID != rhs_storage._cliqueID {return false}
        if _storage._apiRequestURL != rhs_storage._apiRequestURL {return false}
        if _storage._apiName != rhs_storage._apiName {return false}
        if _storage._apiPwd != rhs_storage._apiPwd {return false}
        if _storage._apiPubKey != rhs_storage._apiPubKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginRequest, rhs: Api_Core_AdminLoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginResponse, rhs: Api_Core_AdminLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "worker_capacity"),
    4: .standard(proto: "daily_service_capacity"),
    5: .same(proto: "password"),
    6: .standard(proto: "clique_id"),
    7: .same(proto: "nimprex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nimprex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 3)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 4)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    if !self.nimprex.isEmpty {
      try visitor.visitSingularStringField(value: self.nimprex, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateTenantRequest, rhs: Api_Core_UpdateTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.password != rhs.password {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.nimprex != rhs.nimprex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_PublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PublicKeyResponse, rhs: Api_Core_PublicKeyResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryTenantInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTenantInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryTenantInfoResponse, rhs: Api_Core_QueryTenantInfoResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateNimInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNimInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workerId"),
    2: .same(proto: "nimid"),
    3: .same(proto: "nimsession"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nimid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nimsession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.nimid.isEmpty {
      try visitor.visitSingularStringField(value: self.nimid, fieldNumber: 2)
    }
    if !self.nimsession.isEmpty {
      try visitor.visitSingularStringField(value: self.nimsession, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateNimInfoRequest, rhs: Api_Core_UpdateNimInfoRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.nimid != rhs.nimid {return false}
    if lhs.nimsession != rhs.nimsession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._versionID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_VersionRequest, rhs: Api_Core_VersionRequest) -> Bool {
    if lhs._versionID != rhs._versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .standard(proto: "create_at"),
    11: .standard(proto: "update_at"),
    12: .same(proto: "status"),
    13: .same(proto: "operator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._updateAt) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try { if let v = self._createAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._updateAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 12)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_VersionResponse, rhs: Api_Core_VersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs._createAt != rhs._createAt {return false}
    if lhs._updateAt != rhs._updateAt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CreateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CreateVersionResponse, rhs: Api_Core_CreateVersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .standard(proto: "create_at"),
    11: .standard(proto: "update_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._updateAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try { if let v = self._createAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._updateAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateVersionResponse, rhs: Api_Core_UpdateVersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs._createAt != rhs._createAt {return false}
    if lhs._updateAt != rhs._updateAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetVersionResponse, rhs: Api_Core_GetVersionResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantThirdSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantThirdSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "api_request_url"),
    3: .standard(proto: "api_name"),
    4: .standard(proto: "api_pwd"),
    5: .standard(proto: "api_pubKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.apiRequestURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.apiPwd) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.apiPubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.apiRequestURL.isEmpty {
      try visitor.visitSingularStringField(value: self.apiRequestURL, fieldNumber: 2)
    }
    if !self.apiName.isEmpty {
      try visitor.visitSingularStringField(value: self.apiName, fieldNumber: 3)
    }
    if !self.apiPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.apiPwd, fieldNumber: 4)
    }
    if !self.apiPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiPubKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantThirdSetting, rhs: Api_Core_TenantThirdSetting) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.apiRequestURL != rhs.apiRequestURL {return false}
    if lhs.apiName != rhs.apiName {return false}
    if lhs.apiPwd != rhs.apiPwd {return false}
    if lhs.apiPubKey != rhs.apiPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
