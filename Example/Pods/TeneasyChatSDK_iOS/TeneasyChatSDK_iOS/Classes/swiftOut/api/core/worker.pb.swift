// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/worker.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 查询客服
public struct Api_Core_WorkerQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var queryType: Int32 {
    get {return _queryType ?? 0}
    set {_queryType = newValue}
  }
  /// Returns true if `queryType` has been explicitly set.
  public var hasQueryType: Bool {return self._queryType != nil}
  /// Clears the value of `queryType`. Subsequent reads from it will return its default value.
  public mutating func clearQueryType() {self._queryType = nil}

  public var groupPid: Int64 {
    get {return _groupPid ?? 0}
    set {_groupPid = newValue}
  }
  /// Returns true if `groupPid` has been explicitly set.
  public var hasGroupPid: Bool {return self._groupPid != nil}
  /// Clears the value of `groupPid`. Subsequent reads from it will return its default value.
  public mutating func clearGroupPid() {self._groupPid = nil}

  public var groupCid: Int64 {
    get {return _groupCid ?? 0}
    set {_groupCid = newValue}
  }
  /// Returns true if `groupCid` has been explicitly set.
  public var hasGroupCid: Bool {return self._groupCid != nil}
  /// Clears the value of `groupCid`. Subsequent reads from it will return its default value.
  public mutating func clearGroupCid() {self._groupCid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
  fileprivate var _name: String? = nil
  fileprivate var _queryType: Int32? = nil
  fileprivate var _groupPid: Int64? = nil
  fileprivate var _groupCid: Int64? = nil
}

public struct Api_Core_WorkerQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Api_Common_Worker] = []

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_WorkerQuerySelfResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var self_p: Api_Common_Worker {
    get {return _self_p ?? Api_Common_Worker()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _self_p: Api_Common_Worker? = nil
}

///申请客服云信账号
public struct Api_Core_NIMAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var name: String = String()

  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///回复客服云信账号
public struct Api_Core_NIMAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///账号
  public var nimaccid: String = String()

  ///姓名
  public var nimname: String = String()

  ///token
  public var nimtoken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 创建客服
public struct Api_Core_WorkerCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客服账号
  public var account: String = String()

  public var password: String = String()

  /// 所在的组
  public var groupIds: [Int64] = []

  /// 权限掩码, 理解有困难的话 随时可调
  public var permMask: Int32 = 0

  /// 客服名
  public var name: String = String()

  /// 头像url, 预留
  public var avatar: String = String()

  /// 是否创建云信账号
  public var bneednim: Bool {
    get {return _bneednim ?? false}
    set {_bneednim = newValue}
  }
  /// Returns true if `bneednim` has been explicitly set.
  public var hasBneednim: Bool {return self._bneednim != nil}
  /// Clears the value of `bneednim`. Subsequent reads from it will return its default value.
  public mutating func clearBneednim() {self._bneednim = nil}

  ///云信头像,需要外部拼接
  public var avatarurl: String {
    get {return _avatarurl ?? String()}
    set {_avatarurl = newValue}
  }
  /// Returns true if `avatarurl` has been explicitly set.
  public var hasAvatarurl: Bool {return self._avatarurl != nil}
  /// Clears the value of `avatarurl`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarurl() {self._avatarurl = nil}

  /// 消息提示
  public var tips: String {
    get {return _tips ?? String()}
    set {_tips = newValue}
  }
  /// Returns true if `tips` has been explicitly set.
  public var hasTips: Bool {return self._tips != nil}
  /// Clears the value of `tips`. Subsequent reads from it will return its default value.
  public mutating func clearTips() {self._tips = nil}

  public var groupCids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bneednim: Bool? = nil
  fileprivate var _avatarurl: String? = nil
  fileprivate var _tips: String? = nil
}

/// 更新客服
/// 为何不做全量修改:
/// 密码前端不知道, 修改后才能请求
public struct Api_Core_WorkerUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var password: String {
    get {return _password ?? String()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  public var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  public mutating func clearPassword() {self._password = nil}

  /// 所在的组
  public var groupIds: CommonSetInt64 {
    get {return _groupIds ?? CommonSetInt64()}
    set {_groupIds = newValue}
  }
  /// Returns true if `groupIds` has been explicitly set.
  public var hasGroupIds: Bool {return self._groupIds != nil}
  /// Clears the value of `groupIds`. Subsequent reads from it will return its default value.
  public mutating func clearGroupIds() {self._groupIds = nil}

  /// 权限掩码, 前端理解有困难的话 随时可调
  public var permMask: Int32 {
    get {return _permMask ?? 0}
    set {_permMask = newValue}
  }
  /// Returns true if `permMask` has been explicitly set.
  public var hasPermMask: Bool {return self._permMask != nil}
  /// Clears the value of `permMask`. Subsequent reads from it will return its default value.
  public mutating func clearPermMask() {self._permMask = nil}

  /// 客服名
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// 头像url, 预留
  public var avatar: String {
    get {return _avatar ?? String()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  public var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  public mutating func clearAvatar() {self._avatar = nil}

  /// 云信Id
  public var nimid: String {
    get {return _nimid ?? String()}
    set {_nimid = newValue}
  }
  /// Returns true if `nimid` has been explicitly set.
  public var hasNimid: Bool {return self._nimid != nil}
  /// Clears the value of `nimid`. Subsequent reads from it will return its default value.
  public mutating func clearNimid() {self._nimid = nil}

  /// 云信session
  public var nimtoken: String {
    get {return _nimtoken ?? String()}
    set {_nimtoken = newValue}
  }
  /// Returns true if `nimtoken` has been explicitly set.
  public var hasNimtoken: Bool {return self._nimtoken != nil}
  /// Clears the value of `nimtoken`. Subsequent reads from it will return its default value.
  public mutating func clearNimtoken() {self._nimtoken = nil}

  /// 消息提示
  public var tips: String {
    get {return _tips ?? String()}
    set {_tips = newValue}
  }
  /// Returns true if `tips` has been explicitly set.
  public var hasTips: Bool {return self._tips != nil}
  /// Clears the value of `tips`. Subsequent reads from it will return its default value.
  public mutating func clearTips() {self._tips = nil}

  public var groupCids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _password: String? = nil
  fileprivate var _groupIds: CommonSetInt64? = nil
  fileprivate var _permMask: Int32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _avatar: String? = nil
  fileprivate var _nimid: String? = nil
  fileprivate var _nimtoken: String? = nil
  fileprivate var _tips: String? = nil
}

public struct Api_Core_WorkerSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var sessionID: Int32 = 0

  public var connectState: Api_Common_ConnectState = .offline

  public var onlineState: Api_Common_OnlineState = .idle

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除客服
public struct Api_Core_WorkerDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// worker_id 1 = 商户账号, 不可操作
  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 将指定聊天会话转给指定客服
public struct Api_Core_WorkerTransferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var workerID: Int32 = 0

  /// 咨询id
  public var consultID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 将指定聊天会话转给指定客服
public struct Api_Core_WorkerTransferConsultsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var groupid: [Int64] = []

  /// 咨询id
  public var consultID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 将指定聊天会话转给指定客服
public struct Api_Core_WorkerTransferConsultsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var worker: Api_Common_Worker {
    get {return _worker ?? Api_Common_Worker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _worker: Api_Common_Worker? = nil
}

public struct Api_Core_BlacklistApplyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  /// 转给有权限的客服目标
  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_BlacklistConfirmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_BlacklistRecoverRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_CheckWorkerStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var worker: Api_Common_Worker {
    get {return _worker ?? Api_Common_Worker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _worker: Api_Common_Worker? = nil
}

public struct Api_Core_CheckWorkerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 咨询id
  public var consultID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_GetWorkerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var connectState: Api_Common_ConnectState {
    get {return _connectState ?? .offline}
    set {_connectState = newValue}
  }
  /// Returns true if `connectState` has been explicitly set.
  public var hasConnectState: Bool {return self._connectState != nil}
  /// Clears the value of `connectState`. Subsequent reads from it will return its default value.
  public mutating func clearConnectState() {self._connectState = nil}

  public var onlineState: Api_Common_OnlineState {
    get {return _onlineState ?? .idle}
    set {_onlineState = newValue}
  }
  /// Returns true if `onlineState` has been explicitly set.
  public var hasOnlineState: Bool {return self._onlineState != nil}
  /// Clears the value of `onlineState`. Subsequent reads from it will return its default value.
  public mutating func clearOnlineState() {self._onlineState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _connectState: Api_Common_ConnectState? = nil
  fileprivate var _onlineState: Api_Common_OnlineState? = nil
}

public struct Api_Core_GetWorkerStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerSession: [Api_Core_WorkerSession] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_SetWorkerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var onlineState: Api_Common_OnlineState = .idle

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_WorkerTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var worker: Api_Common_Worker {
    get {return _worker ?? Api_Common_Worker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _worker: Api_Common_Worker? = nil
}

public struct Api_Core_PasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var oldPassword: String = String()

  public var newPassword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryFronterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客服名称
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_QueryFronterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Api_Core_QueryFronterItem] = []

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryFronterItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客服名称
  public var name: String = String()

  /// 用户名
  public var account: String = String()

  /// 客服组
  public var group: [String] = []

  /// 是否是主管
  public var isManager: Bool = false

  /// 客服id
  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_DataQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 统计时间开始时间
  public var startTime: String {
    get {return _startTime ?? String()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// 统计时间结束时间
  public var endTime: String {
    get {return _endTime ?? String()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// 客服组
  public var groupID: [Int32] = []

  /// 客服身份
  public var workerIdentity: Api_Common_WorkerPermission {
    get {return _workerIdentity ?? .workerPermNone}
    set {_workerIdentity = newValue}
  }
  /// Returns true if `workerIdentity` has been explicitly set.
  public var hasWorkerIdentity: Bool {return self._workerIdentity != nil}
  /// Clears the value of `workerIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerIdentity() {self._workerIdentity = nil}

  /// 客服名称
  public var page: CommonPage {
    get {return _page ?? CommonPage()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: String? = nil
  fileprivate var _endTime: String? = nil
  fileprivate var _workerIdentity: Api_Common_WorkerPermission? = nil
  fileprivate var _page: CommonPage? = nil
}

public struct Api_Core_DataQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [Api_Core_DataQueryItem] = []

  public var total: Int32 = 0

  /// 统计人数
  public var countPlayer: Int32 = 0

  /// 平均3分钟回复率
  public var threeRate: Float = 0

  /// 平均响应时长
  public var responseTime: Float = 0

  /// 平均服务时长
  public var serverTime: Float = 0

  /// 累计在线时长
  public var countOnlineTime: Float = 0

  /// 平均接任务数
  public var acceptedNum: Int32 = 0

  /// 平均转任务数
  public var transferTask: Int32 = 0

  /// 客服上限人数
  public var workerLimit: Int32 = 0

  /// 现有客服人数
  public var currentWorkers: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_DataQueryItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客服名称
  public var name: String = String()

  /// 分配人数
  public var matchNum: Int32 = 0

  /// 3分钟回复率
  public var threeResponseRate: String = String()

  /// 转任务数
  public var switchingTask: Int32 = 0

  /// 接受任务数
  public var acceptAssignment: Int32 = 0

  /// 平均响应时长
  public var correspondingTime: Float = 0

  /// 所在组
  public var belongGroup: [String] = []

  /// 是否是一线客服
  public var firstLine: Bool = false

  /// 是否是主管
  public var isManager: Bool = false

  /// 平均服务时长
  public var averageTime: Float = 0

  /// 累计在线时长
  public var accumulatedOnlineDuration: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查询指定权限客服, 目前只开发 查询 可转移权限, 可拉黑名单权限
public struct Api_Core_QuerySpecPermWorkerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var perm: Api_Common_WorkerPermission = .workerPermNone

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_WorkerListByGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: Api_Common_WorkerGroup {
    get {return _group ?? Api_Common_WorkerGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var worker: [Api_Common_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: Api_Common_WorkerGroup? = nil
}

public struct Api_Core_QuerySpecPermWorkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groups: [Api_Core_WorkerListByGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TryCleanupAssignedWorkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cleaned: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_UnfreezeSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_UnfreezeSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: CommonChatState = .common

  public var chat: CommonChatItem {
    get {return _chat ?? CommonChatItem()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: CommonChatItem? = nil
}

public struct Api_Core_QuerySessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QuerySessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chat: CommonChatItem {
    get {return _chat ?? CommonChatItem()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: CommonChatItem? = nil
}

/// 商户通知到客户端
public struct Api_Core_NotifyMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///咨询id
  public var consultid: Int32 = 0

  public var userid: Int32 = 0

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TransferMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_WithDraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var orderNo: String = String()

  public var userid: Int64 = 0

  public var money: String = String()

  public var status: Int64 = 0

  public var applyTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TransferMessageRsp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Api_Core_WithDraw] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryChildByGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryChildByGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: [Api_Common_WorkerGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_WorkerQueryRequest: @unchecked Sendable {}
extension Api_Core_WorkerQueryResponse: @unchecked Sendable {}
extension Api_Core_WorkerQuerySelfResponse: @unchecked Sendable {}
extension Api_Core_NIMAccountRequest: @unchecked Sendable {}
extension Api_Core_NIMAccountResponse: @unchecked Sendable {}
extension Api_Core_WorkerCreateRequest: @unchecked Sendable {}
extension Api_Core_WorkerUpdateRequest: @unchecked Sendable {}
extension Api_Core_WorkerSession: @unchecked Sendable {}
extension Api_Core_WorkerDeleteRequest: @unchecked Sendable {}
extension Api_Core_WorkerTransferRequest: @unchecked Sendable {}
extension Api_Core_WorkerTransferConsultsRequest: @unchecked Sendable {}
extension Api_Core_WorkerTransferConsultsResponse: @unchecked Sendable {}
extension Api_Core_BlacklistApplyRequest: @unchecked Sendable {}
extension Api_Core_BlacklistConfirmRequest: @unchecked Sendable {}
extension Api_Core_BlacklistRecoverRequest: @unchecked Sendable {}
extension Api_Core_CheckWorkerStatusResponse: @unchecked Sendable {}
extension Api_Core_CheckWorkerStatusRequest: @unchecked Sendable {}
extension Api_Core_GetWorkerStatusRequest: @unchecked Sendable {}
extension Api_Core_GetWorkerStatusResponse: @unchecked Sendable {}
extension Api_Core_SetWorkerStatusRequest: @unchecked Sendable {}
extension Api_Core_WorkerTransferResponse: @unchecked Sendable {}
extension Api_Core_PasswordRequest: @unchecked Sendable {}
extension Api_Core_QueryFronterRequest: @unchecked Sendable {}
extension Api_Core_QueryFronterResponse: @unchecked Sendable {}
extension Api_Core_QueryFronterItem: @unchecked Sendable {}
extension Api_Core_DataQueryRequest: @unchecked Sendable {}
extension Api_Core_DataQueryResponse: @unchecked Sendable {}
extension Api_Core_DataQueryItem: @unchecked Sendable {}
extension Api_Core_QuerySpecPermWorkerRequest: @unchecked Sendable {}
extension Api_Core_WorkerListByGroup: @unchecked Sendable {}
extension Api_Core_QuerySpecPermWorkerResponse: @unchecked Sendable {}
extension Api_Core_TryCleanupAssignedWorkerResponse: @unchecked Sendable {}
extension Api_Core_UnfreezeSessionRequest: @unchecked Sendable {}
extension Api_Core_UnfreezeSessionResponse: @unchecked Sendable {}
extension Api_Core_QuerySessionRequest: @unchecked Sendable {}
extension Api_Core_QuerySessionResponse: @unchecked Sendable {}
extension Api_Core_NotifyMessageRequest: @unchecked Sendable {}
extension Api_Core_TransferMessageReq: @unchecked Sendable {}
extension Api_Core_WithDraw: @unchecked Sendable {}
extension Api_Core_TransferMessageRsp: @unchecked Sendable {}
extension Api_Core_QueryChildByGroupRequest: @unchecked Sendable {}
extension Api_Core_QueryChildByGroupResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_WorkerQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "name"),
    3: .same(proto: "queryType"),
    4: .standard(proto: "group_pid"),
    5: .standard(proto: "group_cid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._queryType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._groupPid) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._groupCid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._queryType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupPid {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._groupCid {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerQueryRequest, rhs: Api_Core_WorkerQueryRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._name != rhs._name {return false}
    if lhs._queryType != rhs._queryType {return false}
    if lhs._groupPid != rhs._groupPid {return false}
    if lhs._groupCid != rhs._groupCid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "batch"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerQueryResponse, rhs: Api_Core_WorkerQueryResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerQuerySelfResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerQuerySelfResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "self"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerQuerySelfResponse, rhs: Api_Core_WorkerQuerySelfResponse) -> Bool {
    if lhs._self_p != rhs._self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_NIMAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NIMAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workerID"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_NIMAccountRequest, rhs: Api_Core_NIMAccountRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_NIMAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NIMAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nimaccid"),
    2: .same(proto: "nimname"),
    3: .same(proto: "nimtoken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nimaccid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nimname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nimtoken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nimaccid.isEmpty {
      try visitor.visitSingularStringField(value: self.nimaccid, fieldNumber: 1)
    }
    if !self.nimname.isEmpty {
      try visitor.visitSingularStringField(value: self.nimname, fieldNumber: 2)
    }
    if !self.nimtoken.isEmpty {
      try visitor.visitSingularStringField(value: self.nimtoken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_NIMAccountResponse, rhs: Api_Core_NIMAccountResponse) -> Bool {
    if lhs.nimaccid != rhs.nimaccid {return false}
    if lhs.nimname != rhs.nimname {return false}
    if lhs.nimtoken != rhs.nimtoken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
    3: .standard(proto: "group_ids"),
    4: .standard(proto: "perm_mask"),
    6: .same(proto: "name"),
    7: .same(proto: "avatar"),
    8: .same(proto: "bneednim"),
    9: .same(proto: "avatarurl"),
    10: .same(proto: "tips"),
    11: .standard(proto: "group_cids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.groupIds) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.permMask) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._bneednim) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._avatarurl) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._tips) }()
      case 11: try { try decoder.decodeRepeatedInt64Field(value: &self.groupCids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.groupIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.groupIds, fieldNumber: 3)
    }
    if self.permMask != 0 {
      try visitor.visitSingularInt32Field(value: self.permMask, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 7)
    }
    try { if let v = self._bneednim {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._avatarurl {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._tips {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    if !self.groupCids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.groupCids, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerCreateRequest, rhs: Api_Core_WorkerCreateRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.permMask != rhs.permMask {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs._bneednim != rhs._bneednim {return false}
    if lhs._avatarurl != rhs._avatarurl {return false}
    if lhs._tips != rhs._tips {return false}
    if lhs.groupCids != rhs.groupCids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .same(proto: "password"),
    3: .standard(proto: "group_ids"),
    5: .standard(proto: "perm_mask"),
    6: .same(proto: "name"),
    7: .same(proto: "avatar"),
    8: .same(proto: "nimid"),
    9: .same(proto: "nimtoken"),
    10: .same(proto: "tips"),
    11: .standard(proto: "group_cids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._password) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._permMask) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._avatar) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._nimid) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._nimtoken) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._tips) }()
      case 11: try { try decoder.decodeRepeatedInt64Field(value: &self.groupCids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._permMask {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._avatar {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._nimid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._nimtoken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._tips {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    if !self.groupCids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.groupCids, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerUpdateRequest, rhs: Api_Core_WorkerUpdateRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs._password != rhs._password {return false}
    if lhs._groupIds != rhs._groupIds {return false}
    if lhs._permMask != rhs._permMask {return false}
    if lhs._name != rhs._name {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._nimid != rhs._nimid {return false}
    if lhs._nimtoken != rhs._nimtoken {return false}
    if lhs._tips != rhs._tips {return false}
    if lhs.groupCids != rhs.groupCids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerSession"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "connect_state"),
    4: .standard(proto: "online_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.connectState) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.onlineState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if self.sessionID != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionID, fieldNumber: 2)
    }
    if self.connectState != .offline {
      try visitor.visitSingularEnumField(value: self.connectState, fieldNumber: 3)
    }
    if self.onlineState != .idle {
      try visitor.visitSingularEnumField(value: self.onlineState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerSession, rhs: Api_Core_WorkerSession) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.connectState != rhs.connectState {return false}
    if lhs.onlineState != rhs.onlineState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerDeleteRequest, rhs: Api_Core_WorkerDeleteRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerTransferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerTransferRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "worker_id"),
    3: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 2)
    }
    if self.consultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.consultID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerTransferRequest, rhs: Api_Core_WorkerTransferRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerTransferConsultsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerTransferConsultsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "groupid"),
    3: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.groupid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if !self.groupid.isEmpty {
      try visitor.visitPackedInt64Field(value: self.groupid, fieldNumber: 2)
    }
    if self.consultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.consultID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerTransferConsultsRequest, rhs: Api_Core_WorkerTransferConsultsRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.groupid != rhs.groupid {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerTransferConsultsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerTransferConsultsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerTransferConsultsResponse, rhs: Api_Core_WorkerTransferConsultsResponse) -> Bool {
    if lhs._worker != rhs._worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_BlacklistApplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistApplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_BlacklistApplyRequest, rhs: Api_Core_BlacklistApplyRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_BlacklistConfirmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistConfirmRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_BlacklistConfirmRequest, rhs: Api_Core_BlacklistConfirmRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_BlacklistRecoverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistRecoverRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_BlacklistRecoverRequest, rhs: Api_Core_BlacklistRecoverRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CheckWorkerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckWorkerStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CheckWorkerStatusResponse, rhs: Api_Core_CheckWorkerStatusResponse) -> Bool {
    if lhs._worker != rhs._worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CheckWorkerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckWorkerStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.consultID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CheckWorkerStatusRequest, rhs: Api_Core_CheckWorkerStatusRequest) -> Bool {
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetWorkerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "connect_state"),
    3: .standard(proto: "online_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._connectState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._onlineState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try { if let v = self._connectState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._onlineState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetWorkerStatusRequest, rhs: Api_Core_GetWorkerStatusRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs._connectState != rhs._connectState {return false}
    if lhs._onlineState != rhs._onlineState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetWorkerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workerSession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workerSession.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerSession, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetWorkerStatusResponse, rhs: Api_Core_GetWorkerStatusResponse) -> Bool {
    if lhs.workerSession != rhs.workerSession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_SetWorkerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "online_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.onlineState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.onlineState != .idle {
      try visitor.visitSingularEnumField(value: self.onlineState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_SetWorkerStatusRequest, rhs: Api_Core_SetWorkerStatusRequest) -> Bool {
    if lhs.onlineState != rhs.onlineState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerTransferResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerTransferResponse, rhs: Api_Core_WorkerTransferResponse) -> Bool {
    if lhs._worker != rhs._worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_PasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PasswordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "old_password"),
    2: .standard(proto: "new_password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PasswordRequest, rhs: Api_Core_PasswordRequest) -> Bool {
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryFronterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryFronterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "batch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryFronterRequest, rhs: Api_Core_QueryFronterRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryFronterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryFronterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryFronterResponse, rhs: Api_Core_QueryFronterResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryFronterItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryFronterItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "account"),
    3: .same(proto: "group"),
    4: .same(proto: "isManager"),
    5: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.group) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isManager) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.group.isEmpty {
      try visitor.visitRepeatedStringField(value: self.group, fieldNumber: 3)
    }
    if self.isManager != false {
      try visitor.visitSingularBoolField(value: self.isManager, fieldNumber: 4)
    }
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryFronterItem, rhs: Api_Core_QueryFronterItem) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.account != rhs.account {return false}
    if lhs.group != rhs.group {return false}
    if lhs.isManager != rhs.isManager {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DataQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "group_id"),
    4: .standard(proto: "worker_identity"),
    5: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._endTime) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.groupID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._workerIdentity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.groupID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.groupID, fieldNumber: 3)
    }
    try { if let v = self._workerIdentity {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DataQueryRequest, rhs: Api_Core_DataQueryRequest) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs._workerIdentity != rhs._workerIdentity {return false}
    if lhs._page != rhs._page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DataQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .same(proto: "total"),
    3: .standard(proto: "count_player"),
    4: .standard(proto: "three_rate"),
    5: .standard(proto: "response_time"),
    6: .standard(proto: "server_time"),
    7: .standard(proto: "count_online_time"),
    8: .standard(proto: "accepted_num"),
    9: .standard(proto: "transfer_task"),
    10: .same(proto: "workerLimit"),
    11: .same(proto: "currentWorkers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.countPlayer) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.threeRate) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.responseTime) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.serverTime) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.countOnlineTime) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.acceptedNum) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.transferTask) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.workerLimit) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.currentWorkers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 2)
    }
    if self.countPlayer != 0 {
      try visitor.visitSingularInt32Field(value: self.countPlayer, fieldNumber: 3)
    }
    if self.threeRate != 0 {
      try visitor.visitSingularFloatField(value: self.threeRate, fieldNumber: 4)
    }
    if self.responseTime != 0 {
      try visitor.visitSingularFloatField(value: self.responseTime, fieldNumber: 5)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularFloatField(value: self.serverTime, fieldNumber: 6)
    }
    if self.countOnlineTime != 0 {
      try visitor.visitSingularFloatField(value: self.countOnlineTime, fieldNumber: 7)
    }
    if self.acceptedNum != 0 {
      try visitor.visitSingularInt32Field(value: self.acceptedNum, fieldNumber: 8)
    }
    if self.transferTask != 0 {
      try visitor.visitSingularInt32Field(value: self.transferTask, fieldNumber: 9)
    }
    if self.workerLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.workerLimit, fieldNumber: 10)
    }
    if self.currentWorkers != 0 {
      try visitor.visitSingularInt32Field(value: self.currentWorkers, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DataQueryResponse, rhs: Api_Core_DataQueryResponse) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.total != rhs.total {return false}
    if lhs.countPlayer != rhs.countPlayer {return false}
    if lhs.threeRate != rhs.threeRate {return false}
    if lhs.responseTime != rhs.responseTime {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.countOnlineTime != rhs.countOnlineTime {return false}
    if lhs.acceptedNum != rhs.acceptedNum {return false}
    if lhs.transferTask != rhs.transferTask {return false}
    if lhs.workerLimit != rhs.workerLimit {return false}
    if lhs.currentWorkers != rhs.currentWorkers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DataQueryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataQueryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "match_num"),
    3: .standard(proto: "three_response_rate"),
    4: .standard(proto: "switching_task"),
    5: .standard(proto: "accept_assignment"),
    6: .standard(proto: "corresponding_time"),
    7: .standard(proto: "belong_group"),
    8: .standard(proto: "first_line"),
    9: .standard(proto: "is_manager"),
    10: .standard(proto: "average_time"),
    11: .standard(proto: "accumulated_online_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.matchNum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.threeResponseRate) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.switchingTask) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.acceptAssignment) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.correspondingTime) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.belongGroup) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.firstLine) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isManager) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.averageTime) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.accumulatedOnlineDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.matchNum != 0 {
      try visitor.visitSingularInt32Field(value: self.matchNum, fieldNumber: 2)
    }
    if !self.threeResponseRate.isEmpty {
      try visitor.visitSingularStringField(value: self.threeResponseRate, fieldNumber: 3)
    }
    if self.switchingTask != 0 {
      try visitor.visitSingularInt32Field(value: self.switchingTask, fieldNumber: 4)
    }
    if self.acceptAssignment != 0 {
      try visitor.visitSingularInt32Field(value: self.acceptAssignment, fieldNumber: 5)
    }
    if self.correspondingTime != 0 {
      try visitor.visitSingularFloatField(value: self.correspondingTime, fieldNumber: 6)
    }
    if !self.belongGroup.isEmpty {
      try visitor.visitRepeatedStringField(value: self.belongGroup, fieldNumber: 7)
    }
    if self.firstLine != false {
      try visitor.visitSingularBoolField(value: self.firstLine, fieldNumber: 8)
    }
    if self.isManager != false {
      try visitor.visitSingularBoolField(value: self.isManager, fieldNumber: 9)
    }
    if self.averageTime != 0 {
      try visitor.visitSingularFloatField(value: self.averageTime, fieldNumber: 10)
    }
    if self.accumulatedOnlineDuration != 0 {
      try visitor.visitSingularFloatField(value: self.accumulatedOnlineDuration, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DataQueryItem, rhs: Api_Core_DataQueryItem) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.matchNum != rhs.matchNum {return false}
    if lhs.threeResponseRate != rhs.threeResponseRate {return false}
    if lhs.switchingTask != rhs.switchingTask {return false}
    if lhs.acceptAssignment != rhs.acceptAssignment {return false}
    if lhs.correspondingTime != rhs.correspondingTime {return false}
    if lhs.belongGroup != rhs.belongGroup {return false}
    if lhs.firstLine != rhs.firstLine {return false}
    if lhs.isManager != rhs.isManager {return false}
    if lhs.averageTime != rhs.averageTime {return false}
    if lhs.accumulatedOnlineDuration != rhs.accumulatedOnlineDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QuerySpecPermWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuerySpecPermWorkerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "perm"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.perm) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.perm != .workerPermNone {
      try visitor.visitSingularEnumField(value: self.perm, fieldNumber: 1)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QuerySpecPermWorkerRequest, rhs: Api_Core_QuerySpecPermWorkerRequest) -> Bool {
    if lhs.perm != rhs.perm {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerListByGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerListByGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "worker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.worker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.worker.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.worker, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerListByGroup, rhs: Api_Core_WorkerListByGroup) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.worker != rhs.worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QuerySpecPermWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuerySpecPermWorkerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QuerySpecPermWorkerResponse, rhs: Api_Core_QuerySpecPermWorkerResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TryCleanupAssignedWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TryCleanupAssignedWorkerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cleaned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cleaned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cleaned != false {
      try visitor.visitSingularBoolField(value: self.cleaned, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TryCleanupAssignedWorkerResponse, rhs: Api_Core_TryCleanupAssignedWorkerResponse) -> Bool {
    if lhs.cleaned != rhs.cleaned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UnfreezeSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfreezeSessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UnfreezeSessionRequest, rhs: Api_Core_UnfreezeSessionRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UnfreezeSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfreezeSessionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .common {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UnfreezeSessionResponse, rhs: Api_Core_UnfreezeSessionResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QuerySessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuerySessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QuerySessionRequest, rhs: Api_Core_QuerySessionRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QuerySessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuerySessionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QuerySessionResponse, rhs: Api_Core_QuerySessionResponse) -> Bool {
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_NotifyMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "consultid"),
    4: .same(proto: "userid"),
    5: .same(proto: "msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.consultid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.userid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consultid != 0 {
      try visitor.visitSingularInt32Field(value: self.consultid, fieldNumber: 3)
    }
    if self.userid != 0 {
      try visitor.visitSingularInt32Field(value: self.userid, fieldNumber: 4)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_NotifyMessageRequest, rhs: Api_Core_NotifyMessageRequest) -> Bool {
    if lhs.consultid != rhs.consultid {return false}
    if lhs.userid != rhs.userid {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TransferMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferMessageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TransferMessageReq, rhs: Api_Core_TransferMessageReq) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WithDraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithDraw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "orderNo"),
    3: .same(proto: "userid"),
    4: .same(proto: "money"),
    5: .same(proto: "status"),
    6: .same(proto: "applyTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orderNo) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.money) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.applyTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.orderNo.isEmpty {
      try visitor.visitSingularStringField(value: self.orderNo, fieldNumber: 2)
    }
    if self.userid != 0 {
      try visitor.visitSingularInt64Field(value: self.userid, fieldNumber: 3)
    }
    if !self.money.isEmpty {
      try visitor.visitSingularStringField(value: self.money, fieldNumber: 4)
    }
    if self.status != 0 {
      try visitor.visitSingularInt64Field(value: self.status, fieldNumber: 5)
    }
    if self.applyTime != 0 {
      try visitor.visitSingularInt64Field(value: self.applyTime, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WithDraw, rhs: Api_Core_WithDraw) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.orderNo != rhs.orderNo {return false}
    if lhs.userid != rhs.userid {return false}
    if lhs.money != rhs.money {return false}
    if lhs.status != rhs.status {return false}
    if lhs.applyTime != rhs.applyTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TransferMessageRsp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferMessageRsp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TransferMessageRsp, rhs: Api_Core_TransferMessageRsp) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryChildByGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryChildByGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryChildByGroupRequest, rhs: Api_Core_QueryChildByGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryChildByGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryChildByGroupResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.group.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.group, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryChildByGroupResponse, rhs: Api_Core_QueryChildByGroupResponse) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
