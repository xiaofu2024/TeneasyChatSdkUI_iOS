// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/scylla.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// https://docs.scylladb.com/stable/cql/ddl.html#tombstones-gc-options
public enum Api_TombstoneGCMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case timeout // = 0
  case repair // = 1
  case disabled // = 2
  case immediate // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .timeout
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .timeout
    case 1: self = .repair
    case 2: self = .disabled
    case 3: self = .immediate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .timeout: return 0
    case .repair: return 1
    case .disabled: return 2
    case .immediate: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_TombstoneGCMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_TombstoneGCMode] = [
    .timeout,
    .repair,
    .disabled,
    .immediate,
  ]
}

#endif  // swift(>=4.2)

public enum Api_CompactionWindowUnit: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case days // = 0
  case hours // = 1
  case minutes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .days
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .days
    case 1: self = .hours
    case 2: self = .minutes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .days: return 0
    case .hours: return 1
    case .minutes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_CompactionWindowUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_CompactionWindowUnit] = [
    .days,
    .hours,
    .minutes,
  ]
}

#endif  // swift(>=4.2)

public enum Api_CompressionMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case lz4Compressor // = 0
  case snappyCompressor // = 1
  case deflateCompressor // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .lz4Compressor
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lz4Compressor
    case 1: self = .snappyCompressor
    case 2: self = .deflateCompressor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .lz4Compressor: return 0
    case .snappyCompressor: return 1
    case .deflateCompressor: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_CompressionMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_CompressionMode] = [
    .lz4Compressor,
    .snappyCompressor,
    .deflateCompressor,
  ]
}

#endif  // swift(>=4.2)

public enum Api_OrderBy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case obAes // = 0
  case obDesc // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .obAes
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .obAes
    case 1: self = .obDesc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .obAes: return 0
    case .obDesc: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_OrderBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_OrderBy] = [
    .obAes,
    .obDesc,
  ]
}

#endif  // swift(>=4.2)

/// 基础类型未显式声明则按下方类型对应关系:
/// NT_INT = [u]int32, sint32, fixed32, sfixed32
/// NT_BIG_INT = [u]int64, sint64, fixed64, sfixed64
/// NT_DOUBLE = double
/// NT_FLOAT = float
/// NT_BOOLEAN = bool
/// NT_VARCHAR = string
/// NT_BLOB = bytes
/// NT_TIMESTAMP = google.protobuf.timestamp
public enum Api_NativeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ntUnknown // = 0
  case ntBoolean // = 1
  case ntTinyInt // = 2
  case ntSmallInt // = 3
  case ntInt // = 4
  case ntBigInt // = 5
  case ntVarInt // = 6
  case ntCounter // = 7
  case ntDecimal // = 8
  case ntFloat // = 9
  case ntDouble // = 10
  case ntDuration // = 11
  case ntDate // = 12
  case ntTime // = 13
  case ntTimestamp // = 14
  case ntUuid // = 15
  case ntTimeUuid // = 16
  case ntAscii // = 17
  case ntVarchar // = 18
  case ntBlob // = 19
  case ntInet // = 20
  case UNRECOGNIZED(Int)

  public init() {
    self = .ntUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ntUnknown
    case 1: self = .ntBoolean
    case 2: self = .ntTinyInt
    case 3: self = .ntSmallInt
    case 4: self = .ntInt
    case 5: self = .ntBigInt
    case 6: self = .ntVarInt
    case 7: self = .ntCounter
    case 8: self = .ntDecimal
    case 9: self = .ntFloat
    case 10: self = .ntDouble
    case 11: self = .ntDuration
    case 12: self = .ntDate
    case 13: self = .ntTime
    case 14: self = .ntTimestamp
    case 15: self = .ntUuid
    case 16: self = .ntTimeUuid
    case 17: self = .ntAscii
    case 18: self = .ntVarchar
    case 19: self = .ntBlob
    case 20: self = .ntInet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ntUnknown: return 0
    case .ntBoolean: return 1
    case .ntTinyInt: return 2
    case .ntSmallInt: return 3
    case .ntInt: return 4
    case .ntBigInt: return 5
    case .ntVarInt: return 6
    case .ntCounter: return 7
    case .ntDecimal: return 8
    case .ntFloat: return 9
    case .ntDouble: return 10
    case .ntDuration: return 11
    case .ntDate: return 12
    case .ntTime: return 13
    case .ntTimestamp: return 14
    case .ntUuid: return 15
    case .ntTimeUuid: return 16
    case .ntAscii: return 17
    case .ntVarchar: return 18
    case .ntBlob: return 19
    case .ntInet: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_NativeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_NativeType] = [
    .ntUnknown,
    .ntBoolean,
    .ntTinyInt,
    .ntSmallInt,
    .ntInt,
    .ntBigInt,
    .ntVarInt,
    .ntCounter,
    .ntDecimal,
    .ntFloat,
    .ntDouble,
    .ntDuration,
    .ntDate,
    .ntTime,
    .ntTimestamp,
    .ntUuid,
    .ntTimeUuid,
    .ntAscii,
    .ntVarchar,
    .ntBlob,
    .ntInet,
  ]
}

#endif  // swift(>=4.2)

public struct Api_SimpleStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicationFactor: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_NetworkTopologyStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key: 数据中心名称, value: 副本因子
  public var replicationFactor: Dictionary<String,Int32> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_KeySpaceOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var strategy: Api_KeySpaceOption.OneOf_Strategy? = nil

  public var ss: Api_SimpleStrategy {
    get {
      if case .ss(let v)? = strategy {return v}
      return Api_SimpleStrategy()
    }
    set {strategy = .ss(newValue)}
  }

  public var nts: Api_NetworkTopologyStrategy {
    get {
      if case .nts(let v)? = strategy {return v}
      return Api_NetworkTopologyStrategy()
    }
    set {strategy = .nts(newValue)}
  }

  public var durableWrites: Bool {
    get {return _durableWrites ?? false}
    set {_durableWrites = newValue}
  }
  /// Returns true if `durableWrites` has been explicitly set.
  public var hasDurableWrites: Bool {return self._durableWrites != nil}
  /// Clears the value of `durableWrites`. Subsequent reads from it will return its default value.
  public mutating func clearDurableWrites() {self._durableWrites = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Strategy: Equatable {
    case ss(Api_SimpleStrategy)
    case nts(Api_NetworkTopologyStrategy)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_KeySpaceOption.OneOf_Strategy, rhs: Api_KeySpaceOption.OneOf_Strategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ss, .ss): return {
        guard case .ss(let l) = lhs, case .ss(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nts, .nts): return {
        guard case .nts(let l) = lhs, case .nts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _durableWrites: Bool? = nil
}

/// https://docs.scylladb.com/stable/cql/ddl.html#speculative-retry-options
/// 单副本模式下使用使用会报错: ServerError: sstring out of range
public struct Api_SpeculativeRetry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: Api_SpeculativeRetry.OneOf_Options? = nil

  /// 0-100, 百分比
  public var percentile: Double {
    get {
      if case .percentile(let v)? = options {return v}
      return 0
    }
    set {options = .percentile(newValue)}
  }

  public var milliseconds: Int64 {
    get {
      if case .milliseconds(let v)? = options {return v}
      return 0
    }
    set {options = .milliseconds(newValue)}
  }

  public var always: Bool {
    get {
      if case .always(let v)? = options {return v}
      return false
    }
    set {options = .always(newValue)}
  }

  public var none: Bool {
    get {
      if case .none(let v)? = options {return v}
      return false
    }
    set {options = .none(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Options: Equatable {
    /// 0-100, 百分比
    case percentile(Double)
    case milliseconds(Int64)
    case always(Bool)
    case none(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_SpeculativeRetry.OneOf_Options, rhs: Api_SpeculativeRetry.OneOf_Options) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.percentile, .percentile): return {
        guard case .percentile(let l) = lhs, case .percentile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.milliseconds, .milliseconds): return {
        guard case .milliseconds(let l) = lhs, case .milliseconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.always, .always): return {
        guard case .always(let l) = lhs, case .always(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.none, .none): return {
        guard case .none(let l) = lhs, case .none(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// https://docs.scylladb.com/stable/cql/compaction.html#size-tiered-compaction-strategy-stcs
/// 所有策略默认值均参考官方(即不指定则使用官方参数)
public struct Api_STCS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketHigh: Double {
    get {return _bucketHigh ?? 0}
    set {_bucketHigh = newValue}
  }
  /// Returns true if `bucketHigh` has been explicitly set.
  public var hasBucketHigh: Bool {return self._bucketHigh != nil}
  /// Clears the value of `bucketHigh`. Subsequent reads from it will return its default value.
  public mutating func clearBucketHigh() {self._bucketHigh = nil}

  public var bucketLow: Double {
    get {return _bucketLow ?? 0}
    set {_bucketLow = newValue}
  }
  /// Returns true if `bucketLow` has been explicitly set.
  public var hasBucketLow: Bool {return self._bucketLow != nil}
  /// Clears the value of `bucketLow`. Subsequent reads from it will return its default value.
  public mutating func clearBucketLow() {self._bucketLow = nil}

  public var minSstableSize: Int64 {
    get {return _minSstableSize ?? 0}
    set {_minSstableSize = newValue}
  }
  /// Returns true if `minSstableSize` has been explicitly set.
  public var hasMinSstableSize: Bool {return self._minSstableSize != nil}
  /// Clears the value of `minSstableSize`. Subsequent reads from it will return its default value.
  public mutating func clearMinSstableSize() {self._minSstableSize = nil}

  public var minThreshold: Int64 {
    get {return _minThreshold ?? 0}
    set {_minThreshold = newValue}
  }
  /// Returns true if `minThreshold` has been explicitly set.
  public var hasMinThreshold: Bool {return self._minThreshold != nil}
  /// Clears the value of `minThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMinThreshold() {self._minThreshold = nil}

  public var maxThreshold: Int64 {
    get {return _maxThreshold ?? 0}
    set {_maxThreshold = newValue}
  }
  /// Returns true if `maxThreshold` has been explicitly set.
  public var hasMaxThreshold: Bool {return self._maxThreshold != nil}
  /// Clears the value of `maxThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMaxThreshold() {self._maxThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bucketHigh: Double? = nil
  fileprivate var _bucketLow: Double? = nil
  fileprivate var _minSstableSize: Int64? = nil
  fileprivate var _minThreshold: Int64? = nil
  fileprivate var _maxThreshold: Int64? = nil
}

public struct Api_LCS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sstableSizeInMb: Int64 {
    get {return _sstableSizeInMb ?? 0}
    set {_sstableSizeInMb = newValue}
  }
  /// Returns true if `sstableSizeInMb` has been explicitly set.
  public var hasSstableSizeInMb: Bool {return self._sstableSizeInMb != nil}
  /// Clears the value of `sstableSizeInMb`. Subsequent reads from it will return its default value.
  public mutating func clearSstableSizeInMb() {self._sstableSizeInMb = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sstableSizeInMb: Int64? = nil
}

public struct Api_ICS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bucketHigh: Double {
    get {return _bucketHigh ?? 0}
    set {_bucketHigh = newValue}
  }
  /// Returns true if `bucketHigh` has been explicitly set.
  public var hasBucketHigh: Bool {return self._bucketHigh != nil}
  /// Clears the value of `bucketHigh`. Subsequent reads from it will return its default value.
  public mutating func clearBucketHigh() {self._bucketHigh = nil}

  public var bucketLow: Double {
    get {return _bucketLow ?? 0}
    set {_bucketLow = newValue}
  }
  /// Returns true if `bucketLow` has been explicitly set.
  public var hasBucketLow: Bool {return self._bucketLow != nil}
  /// Clears the value of `bucketLow`. Subsequent reads from it will return its default value.
  public mutating func clearBucketLow() {self._bucketLow = nil}

  public var minSstableSize: Int64 {
    get {return _minSstableSize ?? 0}
    set {_minSstableSize = newValue}
  }
  /// Returns true if `minSstableSize` has been explicitly set.
  public var hasMinSstableSize: Bool {return self._minSstableSize != nil}
  /// Clears the value of `minSstableSize`. Subsequent reads from it will return its default value.
  public mutating func clearMinSstableSize() {self._minSstableSize = nil}

  public var minThreshold: Int64 {
    get {return _minThreshold ?? 0}
    set {_minThreshold = newValue}
  }
  /// Returns true if `minThreshold` has been explicitly set.
  public var hasMinThreshold: Bool {return self._minThreshold != nil}
  /// Clears the value of `minThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMinThreshold() {self._minThreshold = nil}

  public var maxThreshold: Int64 {
    get {return _maxThreshold ?? 0}
    set {_maxThreshold = newValue}
  }
  /// Returns true if `maxThreshold` has been explicitly set.
  public var hasMaxThreshold: Bool {return self._maxThreshold != nil}
  /// Clears the value of `maxThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMaxThreshold() {self._maxThreshold = nil}

  public var sstableSizeInMb: Int64 {
    get {return _sstableSizeInMb ?? 0}
    set {_sstableSizeInMb = newValue}
  }
  /// Returns true if `sstableSizeInMb` has been explicitly set.
  public var hasSstableSizeInMb: Bool {return self._sstableSizeInMb != nil}
  /// Clears the value of `sstableSizeInMb`. Subsequent reads from it will return its default value.
  public mutating func clearSstableSizeInMb() {self._sstableSizeInMb = nil}

  public var spaceAmplificationGoal: Double {
    get {return _spaceAmplificationGoal ?? 0}
    set {_spaceAmplificationGoal = newValue}
  }
  /// Returns true if `spaceAmplificationGoal` has been explicitly set.
  public var hasSpaceAmplificationGoal: Bool {return self._spaceAmplificationGoal != nil}
  /// Clears the value of `spaceAmplificationGoal`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceAmplificationGoal() {self._spaceAmplificationGoal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bucketHigh: Double? = nil
  fileprivate var _bucketLow: Double? = nil
  fileprivate var _minSstableSize: Int64? = nil
  fileprivate var _minThreshold: Int64? = nil
  fileprivate var _maxThreshold: Int64? = nil
  fileprivate var _sstableSizeInMb: Int64? = nil
  fileprivate var _spaceAmplificationGoal: Double? = nil
}

public struct Api_TWCS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var compactionWindowUnit: Api_CompactionWindowUnit {
    get {return _compactionWindowUnit ?? .days}
    set {_compactionWindowUnit = newValue}
  }
  /// Returns true if `compactionWindowUnit` has been explicitly set.
  public var hasCompactionWindowUnit: Bool {return self._compactionWindowUnit != nil}
  /// Clears the value of `compactionWindowUnit`. Subsequent reads from it will return its default value.
  public mutating func clearCompactionWindowUnit() {self._compactionWindowUnit = nil}

  public var compactionWindowSize: Int64 {
    get {return _compactionWindowSize ?? 0}
    set {_compactionWindowSize = newValue}
  }
  /// Returns true if `compactionWindowSize` has been explicitly set.
  public var hasCompactionWindowSize: Bool {return self._compactionWindowSize != nil}
  /// Clears the value of `compactionWindowSize`. Subsequent reads from it will return its default value.
  public mutating func clearCompactionWindowSize() {self._compactionWindowSize = nil}

  public var expiredSstableCheckFrequencySeconds: Int64 {
    get {return _expiredSstableCheckFrequencySeconds ?? 0}
    set {_expiredSstableCheckFrequencySeconds = newValue}
  }
  /// Returns true if `expiredSstableCheckFrequencySeconds` has been explicitly set.
  public var hasExpiredSstableCheckFrequencySeconds: Bool {return self._expiredSstableCheckFrequencySeconds != nil}
  /// Clears the value of `expiredSstableCheckFrequencySeconds`. Subsequent reads from it will return its default value.
  public mutating func clearExpiredSstableCheckFrequencySeconds() {self._expiredSstableCheckFrequencySeconds = nil}

  public var minThreshold: Int64 {
    get {return _minThreshold ?? 0}
    set {_minThreshold = newValue}
  }
  /// Returns true if `minThreshold` has been explicitly set.
  public var hasMinThreshold: Bool {return self._minThreshold != nil}
  /// Clears the value of `minThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMinThreshold() {self._minThreshold = nil}

  public var maxThreshold: Int64 {
    get {return _maxThreshold ?? 0}
    set {_maxThreshold = newValue}
  }
  /// Returns true if `maxThreshold` has been explicitly set.
  public var hasMaxThreshold: Bool {return self._maxThreshold != nil}
  /// Clears the value of `maxThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMaxThreshold() {self._maxThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _compactionWindowUnit: Api_CompactionWindowUnit? = nil
  fileprivate var _compactionWindowSize: Int64? = nil
  fileprivate var _expiredSstableCheckFrequencySeconds: Int64? = nil
  fileprivate var _minThreshold: Int64? = nil
  fileprivate var _maxThreshold: Int64? = nil
}

/// https://docs.scylladb.com/stable/cql/ddl.html#compaction-options
public struct Api_CompactionMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Api_CompactionMode.OneOf_Mode? = nil

  public var stcs: Api_STCS {
    get {
      if case .stcs(let v)? = mode {return v}
      return Api_STCS()
    }
    set {mode = .stcs(newValue)}
  }

  public var lcs: Api_LCS {
    get {
      if case .lcs(let v)? = mode {return v}
      return Api_LCS()
    }
    set {mode = .lcs(newValue)}
  }

  public var ics: Api_ICS {
    get {
      if case .ics(let v)? = mode {return v}
      return Api_ICS()
    }
    set {mode = .ics(newValue)}
  }

  public var twcs: Api_TWCS {
    get {
      if case .twcs(let v)? = mode {return v}
      return Api_TWCS()
    }
    set {mode = .twcs(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Mode: Equatable {
    case stcs(Api_STCS)
    case lcs(Api_LCS)
    case ics(Api_ICS)
    case twcs(Api_TWCS)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_CompactionMode.OneOf_Mode, rhs: Api_CompactionMode.OneOf_Mode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stcs, .stcs): return {
        guard case .stcs(let l) = lhs, case .stcs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lcs, .lcs): return {
        guard case .lcs(let l) = lhs, case .lcs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ics, .ics): return {
        guard case .ics(let l) = lhs, case .ics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.twcs, .twcs): return {
        guard case .twcs(let l) = lhs, case .twcs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// https://docs.scylladb.com/stable/cql/ddl.html#compression-options
public struct Api_CompressionOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sstableCompression: Api_CompressionMode {
    get {return _sstableCompression ?? .lz4Compressor}
    set {_sstableCompression = newValue}
  }
  /// Returns true if `sstableCompression` has been explicitly set.
  public var hasSstableCompression: Bool {return self._sstableCompression != nil}
  /// Clears the value of `sstableCompression`. Subsequent reads from it will return its default value.
  public mutating func clearSstableCompression() {self._sstableCompression = nil}

  public var chunkLengthInKb: Int64 {
    get {return _chunkLengthInKb ?? 0}
    set {_chunkLengthInKb = newValue}
  }
  /// Returns true if `chunkLengthInKb` has been explicitly set.
  public var hasChunkLengthInKb: Bool {return self._chunkLengthInKb != nil}
  /// Clears the value of `chunkLengthInKb`. Subsequent reads from it will return its default value.
  public mutating func clearChunkLengthInKb() {self._chunkLengthInKb = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sstableCompression: Api_CompressionMode? = nil
  fileprivate var _chunkLengthInKb: Int64? = nil
}

public struct Api_CDCOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  public var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  public mutating func clearEnabled() {self._enabled = nil}

  public var preimage: Bool {
    get {return _preimage ?? false}
    set {_preimage = newValue}
  }
  /// Returns true if `preimage` has been explicitly set.
  public var hasPreimage: Bool {return self._preimage != nil}
  /// Clears the value of `preimage`. Subsequent reads from it will return its default value.
  public mutating func clearPreimage() {self._preimage = nil}

  public var ttlSec: Int64 {
    get {return _ttlSec ?? 0}
    set {_ttlSec = newValue}
  }
  /// Returns true if `ttlSec` has been explicitly set.
  public var hasTtlSec: Bool {return self._ttlSec != nil}
  /// Clears the value of `ttlSec`. Subsequent reads from it will return its default value.
  public mutating func clearTtlSec() {self._ttlSec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _enabled: Bool? = nil
  fileprivate var _preimage: Bool? = nil
  fileprivate var _ttlSec: Int64? = nil
}

public struct Api_PrimaryKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var partKey: [String] = []

  public var sortKey: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_MaterializedView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不显式指定的情况下, 将使用 table_name_by_part_key 作为规则
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var primaryKey: Api_PrimaryKey {
    get {return _primaryKey ?? Api_PrimaryKey()}
    set {_primaryKey = newValue}
  }
  /// Returns true if `primaryKey` has been explicitly set.
  public var hasPrimaryKey: Bool {return self._primaryKey != nil}
  /// Clears the value of `primaryKey`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryKey() {self._primaryKey = nil}

  public var option: Api_TableNativeOption {
    get {return _option ?? Api_TableNativeOption()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  public var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  public mutating func clearOption() {self._option = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _primaryKey: Api_PrimaryKey? = nil
  fileprivate var _option: Api_TableNativeOption? = nil
}

/// https://docs.scylladb.com/stable/cql/ddl.html#other-table-options
public struct Api_TableNativeOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var comment: String {
    get {return _storage._comment ?? String()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  public var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  public mutating func clearComment() {_uniqueStorage()._comment = nil}

  public var readRepairChance: Double {
    get {return _storage._readRepairChance ?? 0}
    set {_uniqueStorage()._readRepairChance = newValue}
  }
  /// Returns true if `readRepairChance` has been explicitly set.
  public var hasReadRepairChance: Bool {return _storage._readRepairChance != nil}
  /// Clears the value of `readRepairChance`. Subsequent reads from it will return its default value.
  public mutating func clearReadRepairChance() {_uniqueStorage()._readRepairChance = nil}

  public var dclocalReadRepairChance: Double {
    get {return _storage._dclocalReadRepairChance ?? 0}
    set {_uniqueStorage()._dclocalReadRepairChance = newValue}
  }
  /// Returns true if `dclocalReadRepairChance` has been explicitly set.
  public var hasDclocalReadRepairChance: Bool {return _storage._dclocalReadRepairChance != nil}
  /// Clears the value of `dclocalReadRepairChance`. Subsequent reads from it will return its default value.
  public mutating func clearDclocalReadRepairChance() {_uniqueStorage()._dclocalReadRepairChance = nil}

  public var speculativeRetry: Api_SpeculativeRetry {
    get {return _storage._speculativeRetry ?? Api_SpeculativeRetry()}
    set {_uniqueStorage()._speculativeRetry = newValue}
  }
  /// Returns true if `speculativeRetry` has been explicitly set.
  public var hasSpeculativeRetry: Bool {return _storage._speculativeRetry != nil}
  /// Clears the value of `speculativeRetry`. Subsequent reads from it will return its default value.
  public mutating func clearSpeculativeRetry() {_uniqueStorage()._speculativeRetry = nil}

  /// https://docs.scylladb.com/stable/cql/ddl.html#ddl-tombstones-gc
  public var gcGraceSeconds: Int64 {
    get {return _storage._gcGraceSeconds ?? 0}
    set {_uniqueStorage()._gcGraceSeconds = newValue}
  }
  /// Returns true if `gcGraceSeconds` has been explicitly set.
  public var hasGcGraceSeconds: Bool {return _storage._gcGraceSeconds != nil}
  /// Clears the value of `gcGraceSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearGcGraceSeconds() {_uniqueStorage()._gcGraceSeconds = nil}

  public var tombstoneGc: Api_TombstoneGCMode {
    get {return _storage._tombstoneGc ?? .timeout}
    set {_uniqueStorage()._tombstoneGc = newValue}
  }
  /// Returns true if `tombstoneGc` has been explicitly set.
  public var hasTombstoneGc: Bool {return _storage._tombstoneGc != nil}
  /// Clears the value of `tombstoneGc`. Subsequent reads from it will return its default value.
  public mutating func clearTombstoneGc() {_uniqueStorage()._tombstoneGc = nil}

  public var bloomFilterFpChance: Double {
    get {return _storage._bloomFilterFpChance ?? 0}
    set {_uniqueStorage()._bloomFilterFpChance = newValue}
  }
  /// Returns true if `bloomFilterFpChance` has been explicitly set.
  public var hasBloomFilterFpChance: Bool {return _storage._bloomFilterFpChance != nil}
  /// Clears the value of `bloomFilterFpChance`. Subsequent reads from it will return its default value.
  public mutating func clearBloomFilterFpChance() {_uniqueStorage()._bloomFilterFpChance = nil}

  /// seconds
  public var defaultTimeToLive: Int64 {
    get {return _storage._defaultTimeToLive ?? 0}
    set {_uniqueStorage()._defaultTimeToLive = newValue}
  }
  /// Returns true if `defaultTimeToLive` has been explicitly set.
  public var hasDefaultTimeToLive: Bool {return _storage._defaultTimeToLive != nil}
  /// Clears the value of `defaultTimeToLive`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultTimeToLive() {_uniqueStorage()._defaultTimeToLive = nil}

  public var compaction: Api_CompactionMode {
    get {return _storage._compaction ?? Api_CompactionMode()}
    set {_uniqueStorage()._compaction = newValue}
  }
  /// Returns true if `compaction` has been explicitly set.
  public var hasCompaction: Bool {return _storage._compaction != nil}
  /// Clears the value of `compaction`. Subsequent reads from it will return its default value.
  public mutating func clearCompaction() {_uniqueStorage()._compaction = nil}

  public var compress: Api_CompressionOption {
    get {return _storage._compress ?? Api_CompressionOption()}
    set {_uniqueStorage()._compress = newValue}
  }
  /// Returns true if `compress` has been explicitly set.
  public var hasCompress: Bool {return _storage._compress != nil}
  /// Clears the value of `compress`. Subsequent reads from it will return its default value.
  public mutating func clearCompress() {_uniqueStorage()._compress = nil}

  /// https://docs.scylladb.com/stable/cql/ddl.html#cql-caching-options
  public var caching: Bool {
    get {return _storage._caching ?? false}
    set {_uniqueStorage()._caching = newValue}
  }
  /// Returns true if `caching` has been explicitly set.
  public var hasCaching: Bool {return _storage._caching != nil}
  /// Clears the value of `caching`. Subsequent reads from it will return its default value.
  public mutating func clearCaching() {_uniqueStorage()._caching = nil}

  public var cdc: Api_CDCOption {
    get {return _storage._cdc ?? Api_CDCOption()}
    set {_uniqueStorage()._cdc = newValue}
  }
  /// Returns true if `cdc` has been explicitly set.
  public var hasCdc: Bool {return _storage._cdc != nil}
  /// Clears the value of `cdc`. Subsequent reads from it will return its default value.
  public mutating func clearCdc() {_uniqueStorage()._cdc = nil}

  /// 排序
  public var clusteringOrderBy: [Api_ClusteringOrderBy] {
    get {return _storage._clusteringOrderBy}
    set {_uniqueStorage()._clusteringOrderBy = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Api_ClusteringOrderBy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortKey: String = String()

  public var orderBy: Api_OrderBy = .obAes

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_TableOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 可选,不指定将使用message名称作为表名
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var option: Api_TableNativeOption {
    get {return _option ?? Api_TableNativeOption()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  public var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  public mutating func clearOption() {self._option = nil}

  /// 分区键, 聚集键, 次级索引
  /// 如不设置分区键, 将会解析为user defined type
  public var primaryKey: Api_PrimaryKey {
    get {return _primaryKey ?? Api_PrimaryKey()}
    set {_primaryKey = newValue}
  }
  /// Returns true if `primaryKey` has been explicitly set.
  public var hasPrimaryKey: Bool {return self._primaryKey != nil}
  /// Clears the value of `primaryKey`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryKey() {self._primaryKey = nil}

  public var mv: [Api_MaterializedView] = []

  /// 本地次级索引, 自动补全part_key
  public var localSecondaryIndex: [String] = []

  /// 全局次级索引, 性能较 local_secondary_index 弱
  public var globalSecondaryIndex: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _option: Api_TableNativeOption? = nil
  fileprivate var _primaryKey: Api_PrimaryKey? = nil
}

/// 字段暂不支持 repeated map, 对应类型[collections](https://docs.scylladb.com/stable/cql/types.html#collections)
public struct Api_FieldOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 可选,不指定将使用字段名称作为列名
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var ty: Api_FieldOption.OneOf_Ty? = nil

  public var base: Api_NativeType {
    get {
      if case .base(let v)? = ty {return v}
      return .ntUnknown
    }
    set {ty = .base(newValue)}
  }

  /// user defined type, 多数情况下无需显式指定
  public var udt: String {
    get {
      if case .udt(let v)? = ty {return v}
      return String()
    }
    set {ty = .udt(newValue)}
  }

  /// true: 不持久化到数据库, 作为模型临时字段
  public var exclude: Bool {
    get {return _exclude ?? false}
    set {_exclude = newValue}
  }
  /// Returns true if `exclude` has been explicitly set.
  public var hasExclude: Bool {return self._exclude != nil}
  /// Clears the value of `exclude`. Subsequent reads from it will return its default value.
  public mutating func clearExclude() {self._exclude = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Ty: Equatable {
    case base(Api_NativeType)
    /// user defined type, 多数情况下无需显式指定
    case udt(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_FieldOption.OneOf_Ty, rhs: Api_FieldOption.OneOf_Ty) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.base, .base): return {
        guard case .base(let l) = lhs, case .base(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.udt, .udt): return {
        guard case .udt(let l) = lhs, case .udt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _exclude: Bool? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_TombstoneGCMode: @unchecked Sendable {}
extension Api_CompactionWindowUnit: @unchecked Sendable {}
extension Api_CompressionMode: @unchecked Sendable {}
extension Api_OrderBy: @unchecked Sendable {}
extension Api_NativeType: @unchecked Sendable {}
extension Api_SimpleStrategy: @unchecked Sendable {}
extension Api_NetworkTopologyStrategy: @unchecked Sendable {}
extension Api_KeySpaceOption: @unchecked Sendable {}
extension Api_KeySpaceOption.OneOf_Strategy: @unchecked Sendable {}
extension Api_SpeculativeRetry: @unchecked Sendable {}
extension Api_SpeculativeRetry.OneOf_Options: @unchecked Sendable {}
extension Api_STCS: @unchecked Sendable {}
extension Api_LCS: @unchecked Sendable {}
extension Api_ICS: @unchecked Sendable {}
extension Api_TWCS: @unchecked Sendable {}
extension Api_CompactionMode: @unchecked Sendable {}
extension Api_CompactionMode.OneOf_Mode: @unchecked Sendable {}
extension Api_CompressionOption: @unchecked Sendable {}
extension Api_CDCOption: @unchecked Sendable {}
extension Api_PrimaryKey: @unchecked Sendable {}
extension Api_MaterializedView: @unchecked Sendable {}
extension Api_TableNativeOption: @unchecked Sendable {}
extension Api_ClusteringOrderBy: @unchecked Sendable {}
extension Api_TableOption: @unchecked Sendable {}
extension Api_FieldOption: @unchecked Sendable {}
extension Api_FieldOption.OneOf_Ty: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Extension support defined in scylla.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  public var Api_field: Api_FieldOption {
    get {return getExtensionValue(ext: Api_Extensions_field) ?? Api_FieldOption()}
    set {setExtensionValue(ext: Api_Extensions_field, value: newValue)}
  }
  /// Returns true if extension `Api_Extensions_field`
  /// has been explicitly set.
  public var hasApi_field: Bool {
    return hasExtensionValue(ext: Api_Extensions_field)
  }
  /// Clears the value of extension `Api_Extensions_field`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearApi_field() {
    clearExtensionValue(ext: Api_Extensions_field)
  }
}

extension SwiftProtobuf.Google_Protobuf_FileOptions {

  public var Api_keySpace: Api_KeySpaceOption {
    get {return getExtensionValue(ext: Api_Extensions_key_space) ?? Api_KeySpaceOption()}
    set {setExtensionValue(ext: Api_Extensions_key_space, value: newValue)}
  }
  /// Returns true if extension `Api_Extensions_key_space`
  /// has been explicitly set.
  public var hasApi_keySpace: Bool {
    return hasExtensionValue(ext: Api_Extensions_key_space)
  }
  /// Clears the value of extension `Api_Extensions_key_space`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearApi_keySpace() {
    clearExtensionValue(ext: Api_Extensions_key_space)
  }
}

extension SwiftProtobuf.Google_Protobuf_MessageOptions {

  public var Api_table: Api_TableOption {
    get {return getExtensionValue(ext: Api_Extensions_table) ?? Api_TableOption()}
    set {setExtensionValue(ext: Api_Extensions_table, value: newValue)}
  }
  /// Returns true if extension `Api_Extensions_table`
  /// has been explicitly set.
  public var hasApi_table: Bool {
    return hasExtensionValue(ext: Api_Extensions_table)
  }
  /// Clears the value of extension `Api_Extensions_table`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearApi_table() {
    clearExtensionValue(ext: Api_Extensions_table)
  }

}

// MARK: - File's ExtensionMap: Api_Scylla_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Api_Scylla_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Api_Extensions_key_space,
  Api_Extensions_table,
  Api_Extensions_field
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

public let Api_Extensions_key_space = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Api_KeySpaceOption>, SwiftProtobuf.Google_Protobuf_FileOptions>(
  _protobuf_fieldNumber: 53000,
  fieldName: "api.key_space"
)

public let Api_Extensions_table = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Api_TableOption>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 53000,
  fieldName: "api.table"
)

public let Api_Extensions_field = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Api_FieldOption>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 53000,
  fieldName: "api.field"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api"

extension Api_TombstoneGCMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMEOUT"),
    1: .same(proto: "REPAIR"),
    2: .same(proto: "DISABLED"),
    3: .same(proto: "IMMEDIATE"),
  ]
}

extension Api_CompactionWindowUnit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAYS"),
    1: .same(proto: "HOURS"),
    2: .same(proto: "MINUTES"),
  ]
}

extension Api_CompressionMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LZ4Compressor"),
    1: .same(proto: "SnappyCompressor"),
    2: .same(proto: "DeflateCompressor"),
  ]
}

extension Api_OrderBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OB_AES"),
    1: .same(proto: "OB_DESC"),
  ]
}

extension Api_NativeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NT_UNKNOWN"),
    1: .same(proto: "NT_BOOLEAN"),
    2: .same(proto: "NT_TINY_INT"),
    3: .same(proto: "NT_SMALL_INT"),
    4: .same(proto: "NT_INT"),
    5: .same(proto: "NT_BIG_INT"),
    6: .same(proto: "NT_VAR_INT"),
    7: .same(proto: "NT_COUNTER"),
    8: .same(proto: "NT_DECIMAL"),
    9: .same(proto: "NT_FLOAT"),
    10: .same(proto: "NT_DOUBLE"),
    11: .same(proto: "NT_DURATION"),
    12: .same(proto: "NT_DATE"),
    13: .same(proto: "NT_TIME"),
    14: .same(proto: "NT_TIMESTAMP"),
    15: .same(proto: "NT_UUID"),
    16: .same(proto: "NT_TIME_UUID"),
    17: .same(proto: "NT_ASCII"),
    18: .same(proto: "NT_VARCHAR"),
    19: .same(proto: "NT_BLOB"),
    20: .same(proto: "NT_INET"),
  ]
}

extension Api_SimpleStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SimpleStrategy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replication_factor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.replicationFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replicationFactor != 0 {
      try visitor.visitSingularInt32Field(value: self.replicationFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_SimpleStrategy, rhs: Api_SimpleStrategy) -> Bool {
    if lhs.replicationFactor != rhs.replicationFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NetworkTopologyStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkTopologyStrategy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replication_factor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.replicationFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replicationFactor.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.replicationFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_NetworkTopologyStrategy, rhs: Api_NetworkTopologyStrategy) -> Bool {
    if lhs.replicationFactor != rhs.replicationFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_KeySpaceOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeySpaceOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ss"),
    3: .same(proto: "nts"),
    4: .standard(proto: "durable_writes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Api_SimpleStrategy?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .ss(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .ss(v)
        }
      }()
      case 3: try {
        var v: Api_NetworkTopologyStrategy?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .nts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .nts(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._durableWrites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.strategy {
    case .ss?: try {
      guard case .ss(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .nts?: try {
      guard case .nts(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._durableWrites {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_KeySpaceOption, rhs: Api_KeySpaceOption) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.strategy != rhs.strategy {return false}
    if lhs._durableWrites != rhs._durableWrites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SpeculativeRetry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpeculativeRetry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentile"),
    2: .same(proto: "milliseconds"),
    3: .same(proto: "always"),
    4: .same(proto: "none"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.options != nil {try decoder.handleConflictingOneOf()}
          self.options = .percentile(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.options != nil {try decoder.handleConflictingOneOf()}
          self.options = .milliseconds(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.options != nil {try decoder.handleConflictingOneOf()}
          self.options = .always(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.options != nil {try decoder.handleConflictingOneOf()}
          self.options = .none(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.options {
    case .percentile?: try {
      guard case .percentile(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }()
    case .milliseconds?: try {
      guard case .milliseconds(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .always?: try {
      guard case .always(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .none?: try {
      guard case .none(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_SpeculativeRetry, rhs: Api_SpeculativeRetry) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_STCS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".STCS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_high"),
    2: .standard(proto: "bucket_low"),
    3: .standard(proto: "min_sstable_size"),
    4: .standard(proto: "min_threshold"),
    5: .standard(proto: "max_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._bucketHigh) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._bucketLow) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._minSstableSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._minThreshold) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._maxThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bucketHigh {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bucketLow {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minSstableSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_STCS, rhs: Api_STCS) -> Bool {
    if lhs._bucketHigh != rhs._bucketHigh {return false}
    if lhs._bucketLow != rhs._bucketLow {return false}
    if lhs._minSstableSize != rhs._minSstableSize {return false}
    if lhs._minThreshold != rhs._minThreshold {return false}
    if lhs._maxThreshold != rhs._maxThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LCS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LCS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sstable_size_in_mb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._sstableSizeInMb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sstableSizeInMb {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_LCS, rhs: Api_LCS) -> Bool {
    if lhs._sstableSizeInMb != rhs._sstableSizeInMb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ICS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ICS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_high"),
    2: .standard(proto: "bucket_low"),
    3: .standard(proto: "min_sstable_size"),
    4: .standard(proto: "min_threshold"),
    5: .standard(proto: "max_threshold"),
    6: .standard(proto: "sstable_size_in_mb"),
    7: .standard(proto: "space_amplification_goal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._bucketHigh) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._bucketLow) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._minSstableSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._minThreshold) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._maxThreshold) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._sstableSizeInMb) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self._spaceAmplificationGoal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bucketHigh {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bucketLow {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minSstableSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sstableSizeInMb {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._spaceAmplificationGoal {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ICS, rhs: Api_ICS) -> Bool {
    if lhs._bucketHigh != rhs._bucketHigh {return false}
    if lhs._bucketLow != rhs._bucketLow {return false}
    if lhs._minSstableSize != rhs._minSstableSize {return false}
    if lhs._minThreshold != rhs._minThreshold {return false}
    if lhs._maxThreshold != rhs._maxThreshold {return false}
    if lhs._sstableSizeInMb != rhs._sstableSizeInMb {return false}
    if lhs._spaceAmplificationGoal != rhs._spaceAmplificationGoal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_TWCS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TWCS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "compaction_window_unit"),
    2: .standard(proto: "compaction_window_size"),
    3: .standard(proto: "expired_sstable_check_frequency_seconds"),
    4: .standard(proto: "min_threshold"),
    5: .standard(proto: "max_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._compactionWindowUnit) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._compactionWindowSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._expiredSstableCheckFrequencySeconds) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._minThreshold) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._maxThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._compactionWindowUnit {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._compactionWindowSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expiredSstableCheckFrequencySeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxThreshold {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_TWCS, rhs: Api_TWCS) -> Bool {
    if lhs._compactionWindowUnit != rhs._compactionWindowUnit {return false}
    if lhs._compactionWindowSize != rhs._compactionWindowSize {return false}
    if lhs._expiredSstableCheckFrequencySeconds != rhs._expiredSstableCheckFrequencySeconds {return false}
    if lhs._minThreshold != rhs._minThreshold {return false}
    if lhs._maxThreshold != rhs._maxThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CompactionMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompactionMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stcs"),
    2: .same(proto: "lcs"),
    3: .same(proto: "ics"),
    4: .same(proto: "twcs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api_STCS?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .stcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .stcs(v)
        }
      }()
      case 2: try {
        var v: Api_LCS?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .lcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .lcs(v)
        }
      }()
      case 3: try {
        var v: Api_ICS?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .ics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .ics(v)
        }
      }()
      case 4: try {
        var v: Api_TWCS?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .twcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .twcs(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .stcs?: try {
      guard case .stcs(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .lcs?: try {
      guard case .lcs(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ics?: try {
      guard case .ics(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .twcs?: try {
      guard case .twcs(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_CompactionMode, rhs: Api_CompactionMode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CompressionOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompressionOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sstable_compression"),
    2: .standard(proto: "chunk_length_in_kb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sstableCompression) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._chunkLengthInKb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sstableCompression {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._chunkLengthInKb {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_CompressionOption, rhs: Api_CompressionOption) -> Bool {
    if lhs._sstableCompression != rhs._sstableCompression {return false}
    if lhs._chunkLengthInKb != rhs._chunkLengthInKb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CDCOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CDCOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "preimage"),
    3: .standard(proto: "ttl_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._preimage) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._ttlSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._preimage {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ttlSec {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_CDCOption, rhs: Api_CDCOption) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs._preimage != rhs._preimage {return false}
    if lhs._ttlSec != rhs._ttlSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PrimaryKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrimaryKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    13: .standard(proto: "part_key"),
    14: .standard(proto: "sort_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.partKey) }()
      case 14: try { try decoder.decodeRepeatedStringField(value: &self.sortKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partKey.isEmpty {
      try visitor.visitRepeatedStringField(value: self.partKey, fieldNumber: 13)
    }
    if !self.sortKey.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sortKey, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_PrimaryKey, rhs: Api_PrimaryKey) -> Bool {
    if lhs.partKey != rhs.partKey {return false}
    if lhs.sortKey != rhs.sortKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_MaterializedView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaterializedView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "primary_key"),
    3: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._primaryKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._primaryKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_MaterializedView, rhs: Api_MaterializedView) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._primaryKey != rhs._primaryKey {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_TableNativeOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableNativeOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comment"),
    2: .standard(proto: "read_repair_chance"),
    3: .standard(proto: "dclocal_read_repair_chance"),
    4: .standard(proto: "speculative_retry"),
    5: .standard(proto: "gc_grace_seconds"),
    6: .standard(proto: "tombstone_gc"),
    7: .standard(proto: "bloom_filter_fp_chance"),
    8: .standard(proto: "default_time_to_live"),
    9: .same(proto: "compaction"),
    10: .same(proto: "compress"),
    11: .same(proto: "caching"),
    12: .same(proto: "cdc"),
    13: .standard(proto: "clustering_order_by"),
  ]

  fileprivate class _StorageClass {
    var _comment: String? = nil
    var _readRepairChance: Double? = nil
    var _dclocalReadRepairChance: Double? = nil
    var _speculativeRetry: Api_SpeculativeRetry? = nil
    var _gcGraceSeconds: Int64? = nil
    var _tombstoneGc: Api_TombstoneGCMode? = nil
    var _bloomFilterFpChance: Double? = nil
    var _defaultTimeToLive: Int64? = nil
    var _compaction: Api_CompactionMode? = nil
    var _compress: Api_CompressionOption? = nil
    var _caching: Bool? = nil
    var _cdc: Api_CDCOption? = nil
    var _clusteringOrderBy: [Api_ClusteringOrderBy] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _comment = source._comment
      _readRepairChance = source._readRepairChance
      _dclocalReadRepairChance = source._dclocalReadRepairChance
      _speculativeRetry = source._speculativeRetry
      _gcGraceSeconds = source._gcGraceSeconds
      _tombstoneGc = source._tombstoneGc
      _bloomFilterFpChance = source._bloomFilterFpChance
      _defaultTimeToLive = source._defaultTimeToLive
      _compaction = source._compaction
      _compress = source._compress
      _caching = source._caching
      _cdc = source._cdc
      _clusteringOrderBy = source._clusteringOrderBy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._comment) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._readRepairChance) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._dclocalReadRepairChance) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._speculativeRetry) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._gcGraceSeconds) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._tombstoneGc) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._bloomFilterFpChance) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._defaultTimeToLive) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._compaction) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._compress) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._caching) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cdc) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._clusteringOrderBy) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._comment {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._readRepairChance {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dclocalReadRepairChance {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._speculativeRetry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._gcGraceSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tombstoneGc {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bloomFilterFpChance {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._defaultTimeToLive {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._compaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._compress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._caching {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._cdc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._clusteringOrderBy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._clusteringOrderBy, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_TableNativeOption, rhs: Api_TableNativeOption) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._readRepairChance != rhs_storage._readRepairChance {return false}
        if _storage._dclocalReadRepairChance != rhs_storage._dclocalReadRepairChance {return false}
        if _storage._speculativeRetry != rhs_storage._speculativeRetry {return false}
        if _storage._gcGraceSeconds != rhs_storage._gcGraceSeconds {return false}
        if _storage._tombstoneGc != rhs_storage._tombstoneGc {return false}
        if _storage._bloomFilterFpChance != rhs_storage._bloomFilterFpChance {return false}
        if _storage._defaultTimeToLive != rhs_storage._defaultTimeToLive {return false}
        if _storage._compaction != rhs_storage._compaction {return false}
        if _storage._compress != rhs_storage._compress {return false}
        if _storage._caching != rhs_storage._caching {return false}
        if _storage._cdc != rhs_storage._cdc {return false}
        if _storage._clusteringOrderBy != rhs_storage._clusteringOrderBy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ClusteringOrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusteringOrderBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sort_key"),
    2: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sortKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sortKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sortKey, fieldNumber: 1)
    }
    if self.orderBy != .obAes {
      try visitor.visitSingularEnumField(value: self.orderBy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ClusteringOrderBy, rhs: Api_ClusteringOrderBy) -> Bool {
    if lhs.sortKey != rhs.sortKey {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_TableOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "option"),
    3: .standard(proto: "primary_key"),
    4: .same(proto: "mv"),
    5: .standard(proto: "local_secondary_index"),
    6: .standard(proto: "global_secondary_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._primaryKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mv) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.localSecondaryIndex) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.globalSecondaryIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._primaryKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.mv.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mv, fieldNumber: 4)
    }
    if !self.localSecondaryIndex.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localSecondaryIndex, fieldNumber: 5)
    }
    if !self.globalSecondaryIndex.isEmpty {
      try visitor.visitRepeatedStringField(value: self.globalSecondaryIndex, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_TableOption, rhs: Api_TableOption) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._option != rhs._option {return false}
    if lhs._primaryKey != rhs._primaryKey {return false}
    if lhs.mv != rhs.mv {return false}
    if lhs.localSecondaryIndex != rhs.localSecondaryIndex {return false}
    if lhs.globalSecondaryIndex != rhs.globalSecondaryIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_FieldOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "base"),
    3: .same(proto: "udt"),
    4: .same(proto: "exclude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try {
        var v: Api_NativeType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.ty != nil {try decoder.handleConflictingOneOf()}
          self.ty = .base(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.ty != nil {try decoder.handleConflictingOneOf()}
          self.ty = .udt(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._exclude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.ty {
    case .base?: try {
      guard case .base(let v)? = self.ty else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .udt?: try {
      guard case .udt(let v)? = self.ty else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._exclude {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_FieldOption, rhs: Api_FieldOption) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.ty != rhs.ty {return false}
    if lhs._exclude != rhs._exclude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
